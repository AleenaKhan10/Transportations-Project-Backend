{
  "indexed_at": "2025-11-20T06:13:39.334135",
  "root": ".",
  "project_structure": {
    "type": "tree",
    "root": ".",
    "tree": [
      ".",
      "\u251c\u2500\u2500 app/ (82 files)",
      "\u2502   \u251c\u2500\u2500 db/ (3 files)",
      "\u2502   \u251c\u2500\u2500 helpers/ (6 files)",
      "\u2502   \u251c\u2500\u2500 logic/ (12 files)",
      "\u2502   \u2502   \u251c\u2500\u2500 alerts/ (3 files)",
      "\u2502   \u2502   \u251c\u2500\u2500 auth/ (3 files)",
      "\u2502   \u2502   \u2514\u2500\u2500 ingest/ (3 files)",
      "\u2502   \u251c\u2500\u2500 models/ (18 files)",
      "\u2502   \u251c\u2500\u2500 providers/ (3 files)",
      "\u2502   \u251c\u2500\u2500 services/ (34 files)",
      "\u2502   \u2502   \u2514\u2500\u2500 alerts/ (3 files)",
      "\u2502   \u251c\u2500\u2500 utils/ (3 files)",
      "\u2502   \u2514\u2500\u2500 requirements.txt",
      "\u251c\u2500\u2500 bigquery/ (10 files)",
      "\u2502   \u251c\u2500\u2500 creation_queries/ (8 files)",
      "\u2502   \u2514\u2500\u2500 scheduled_queries/ (2 files)",
      "\u2514\u2500\u2500 cloud_functions/ (1 files)",
      "    \u2514\u2500\u2500 get-trip-data/ (1 files)",
      "        \u2514\u2500\u2500 requirements.txt"
    ]
  },
  "documentation_map": {},
  "directory_purposes": {
    "app\\helpers": "Helper functions and utilities",
    "app\\models": "Data models and database schemas",
    "app\\services": "Business logic and external service integrations",
    "app\\utils": "Shared utility functions and helpers",
    "bigquery\\scheduled_queries": "Data models and schemas",
    "app\\logic\\auth": "Authentication and authorization logic"
  },
  "stats": {
    "total_files": 94,
    "total_directories": 18,
    "fully_parsed": {
      "python": 83
    },
    "listed_only": {
      "json": 1,
      "sql": 10
    },
    "markdown_files": 0
  },
  "files": {
    ".claude\\settings.local.json": {
      "language": "json",
      "parsed": false,
      "purpose": "Configuration"
    },
    "app\\config.py": {
      "language": "python",
      "parsed": true,
      "purpose": "Configuration",
      "imports": [
        "pydantic_settings"
      ],
      "functions": {},
      "classes": {
        "Settings": {
          "methods": {},
          "inherits": [
            "BaseSettings"
          ],
          "properties": [
            "DITAT_TOKEN",
            "SAMSARA_TOKEN",
            "DUMMY_TOKEN",
            "WEBHOOK_TOKEN",
            "DB_USER",
            "DB_PASS",
            "DB_HOST",
            "DB_NAME",
            "DB_PORT",
            "INSTANCE_UNIX_SOCKET",
            "CLOUD_RUN_URL",
            "AUTH_ROUTER_PREFIX",
            "TOKEN_ENDPOINT",
            "TOKEN_ENDPOINT_PATH",
            "SECRET_KEY",
            "ALGORITHM",
            "ACCESS_TOKEN_EXPIRE_MINUTES",
            "SLACK_BOT_TOKEN",
            "SLACK_SIGNING_SECRET",
            "ALERTS_APPROACH1_SLACK_CHANNEL",
            "ALERTS_APPROACH2_SLACK_CHANNEL",
            "VAPI_API_KEY",
            "VAPI_ASSISTANT_ID",
            "VAPI_V_ASSITANT_ID",
            "VAPI_V_PHONE_NUMBER_ID",
            "VAPI_V_API_KEY",
            "PORT",
            "PCMILER_API_KEY",
            "VAPI_PHONENUMBER_ID",
            "WEATHER_API_KEY",
            "WEATHER_API_BASE_URL",
            "SMTP_SERVER",
            "SMTP_PORT",
            "SENDER_EMAIL",
            "SENDER_PASSWORD",
            "SENTRY_DSN",
            "SENTRY_ENVIRONMENT",
            "SENTRY_TRACES_SAMPLE_RATE"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\ingest_app.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "fastapi",
        "fastapi.middleware.cors",
        "services",
        "db.database",
        "sqlmodel",
        "uvicorn"
      ],
      "functions": {
        "create_db_and_tables": "()"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\main.py": {
      "language": "python",
      "parsed": true,
      "purpose": "Application entry point",
      "imports": [
        "fastapi",
        "fastapi.middleware.cors",
        "fastapi.responses",
        "sentry_sdk",
        "sentry_sdk.integrations.fastapi",
        "sentry_sdk.integrations.starlette",
        "config",
        "services",
        "services.users",
        "services.vapi",
        "services.reports",
        "services.pcmiler",
        "services.slack",
        "services.weather",
        "services.truck_mapping",
        "services.temp_sensor_mapping",
        "services.trailer_unit_mapping",
        "services.active_load_tracking",
        "services.violation_alerts",
        "services.dispatched_trips",
        "services.driver_mapping",
        "services.driver_prompt_service",
        "services.admin_users",
        "services.admin_roles",
        "services.admin_permissions",
        "services.admin_sessions",
        "services.admin_audit",
        "services.admin_export",
        "services.test_service",
        "services.driver_data",
        "services.driver_triggers",
        "services.page_access_token_service",
        "db.database",
        "sqlmodel",
        "uvicorn"
      ],
      "functions": {
        "create_db_and_tables": "()",
        "before_send": "(event, hint)",
        "global_exception_handler": "async (request: Request, exc: Exception)"
      },
      "classes": {},
      "call_graph": {}
    },
    "cloud_functions\\get-trip-data\\main.py": {
      "language": "python",
      "parsed": true,
      "purpose": "Application entry point",
      "imports": [
        "re",
        "json",
        "pandas_gbq",
        "flask",
        "functions_framework"
      ],
      "functions": {
        "is_trip_id": {
          "signature": "(trip_id: str)",
          "called_by": [
            "get_trip_data",
            "get_id_type"
          ]
        },
        "is_trailer_id": {
          "signature": "(trailer_id: str)",
          "called_by": [
            "get_trip_data",
            "get_id_type"
          ]
        },
        "authenticate": {
          "signature": "(request: Request)",
          "called_by": [
            "get_trailer_and_trips",
            "get_trip_data",
            "DitatAPI.get_token",
            "DitatAPI.get_dispatch_board",
            "DitatAPI.refresh_token"
          ]
        },
        "get_trailer_and_trips": {
          "calls": [
            "authenticate"
          ],
          "signature": "(request: Request)"
        },
        "get_trip_data": {
          "calls": [
            "authenticate",
            "is_trailer_id",
            "is_trip_id"
          ],
          "signature": "(request: Request)"
        }
      },
      "classes": {},
      "constants": {
        "DUMMY_TOKEN": "str"
      },
      "call_graph": {}
    },
    "bigquery\\creation_queries\\create_diamond.bqml_feature_view.sql": {
      "language": "sql",
      "parsed": false
    },
    "bigquery\\creation_queries\\create_diamond.get_master_grouped_subtrip_level.sql": {
      "language": "sql",
      "parsed": false
    },
    "bigquery\\creation_queries\\create_diamond.get_master_with_alerts.sql": {
      "language": "sql",
      "parsed": false
    },
    "bigquery\\creation_queries\\create_diamond.get_master_with_alerts_v2.sql": {
      "language": "sql",
      "parsed": false
    },
    "bigquery\\creation_queries\\create_diamond.master_grouped_subtrip_level.sql": {
      "language": "sql",
      "parsed": false
    },
    "bigquery\\creation_queries\\create_golden.ditat_samsara_merged_master_view.sql": {
      "language": "sql",
      "parsed": false
    },
    "bigquery\\creation_queries\\create_silver.ditat_cleaned_view.sql": {
      "language": "sql",
      "parsed": false
    },
    "bigquery\\creation_queries\\create_silver.samsara_cleaned_view.sql": {
      "language": "sql",
      "parsed": false
    },
    "bigquery\\scheduled_queries\\archive_last_7_days_daily.sql": {
      "language": "sql",
      "parsed": false
    },
    "bigquery\\scheduled_queries\\create_models.reefer_anomaly_detector_v2.sql": {
      "language": "sql",
      "parsed": false,
      "purpose": "Data model"
    },
    "app\\db\\database.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "sqlmodel",
        "sqlalchemy.engine.url",
        "sqlalchemy",
        "config"
      ],
      "functions": {
        "set_search_path": "(dbapi_connection, connection_record)",
        "set_search_path_on_checkout": "(dbapi_connection, connection_record, connection_proxy)"
      },
      "classes": {},
      "constants": {
        "DATABASE_URL": "value"
      },
      "call_graph": {}
    },
    "app\\db\\retry.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "time",
        "functools",
        "typing",
        "sqlalchemy.exc",
        "logging"
      ],
      "functions": {
        "db_retry": {
          "calls": [
            "decorator",
            "wrapper"
          ],
          "signature": "(max_retries: int = 3, delay: float = 1.0, backoff: float = 2.0)"
        }
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\db\\__init__.py": {
      "language": "python",
      "parsed": false
    },
    "app\\helpers\\agy_utils.py": {
      "language": "python",
      "parsed": true,
      "purpose": "Utility functions",
      "imports": [
        "re",
        "enum",
        "fastapi"
      ],
      "functions": {
        "is_trip_id": {
          "signature": "(trip_id: str)",
          "called_by": [
            "get_trip_data",
            "get_id_type"
          ]
        },
        "is_truck_id": {
          "signature": "(truck_id: str)",
          "called_by": [
            "get_id_type"
          ]
        },
        "is_trailer_id": {
          "signature": "(trailer_id: str)",
          "called_by": [
            "get_trip_data",
            "get_id_type"
          ]
        },
        "get_id_type": {
          "calls": [
            "is_trailer_id",
            "is_trip_id",
            "is_truck_id"
          ],
          "signature": "(entity_id: str)",
          "called_by": [
            "is_entity_id"
          ]
        },
        "is_entity_id": {
          "calls": [
            "get_id_type"
          ],
          "signature": "(entity_id: str)",
          "called_by": [
            "validate_entity_id_in_path"
          ]
        },
        "validate_entity_id_in_path": {
          "calls": [
            "is_entity_id"
          ],
          "signature": "(entity_id: str = Path( title=\"Entity ID\", description=f\"Any ID for {IdType.TRIP.value}, {IdType.TRAILER.value} or {IdType.TRUCK.value}\", ),)"
        }
      },
      "classes": {},
      "call_graph": {},
      "enums": {
        "IdType": {
          "values": [
            "TRAILER",
            "TRIP",
            "TRUCK"
          ],
          "doc": ""
        }
      }
    },
    "app\\helpers\\cloud_logger.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "logging",
        "sys"
      ],
      "functions": {
        "create_logger": "(level=logging.INFO)"
      },
      "classes": {
        "CloudLoggingFormatter": {
          "methods": {
            "format": {
              "calls": [
                "format"
              ],
              "signature": "(self, record: logging.LogRecord) -> str",
              "called_by": [
                "CloudLoggingFormatter.format"
              ]
            }
          },
          "inherits": [
            "logging.Formatter"
          ],
          "doc": "Produces messages compatible with google cloud logging"
        }
      },
      "call_graph": {}
    },
    "app\\helpers\\pandas_utils.py": {
      "language": "python",
      "parsed": true,
      "purpose": "Utility functions",
      "imports": [
        "json",
        "enum",
        "collections",
        "pandas",
        "helpers.utils"
      ],
      "functions": {
        "find_python_types": "(df: pd.DataFrame) -> dict[str, TypeCounter[J]]",
        "clean_column_names": "(df: pd.DataFrame, replacements: dict[str, str] = {}, replace_dot_with_next_capital: bool = True,) -> pd.DataFrame"
      },
      "classes": {
        "TypeCounter": {
          "methods": {
            "most_common_type": {
              "decorators": [
                "property"
              ],
              "signature": "(self) -> JsonType"
            }
          },
          "inherits": [
            "Counter"
          ]
        }
      },
      "call_graph": {},
      "enums": {
        "JsonType": {
          "values": [
            "LIST",
            "TUPLE",
            "DICT",
            "STRING",
            "INT",
            "FLOAT",
            "BOOL",
            "NULL",
            "OTHER"
          ],
          "doc": ""
        }
      }
    },
    "app\\helpers\\time_utils.py": {
      "language": "python",
      "parsed": true,
      "purpose": "Utility functions",
      "imports": [
        "enum",
        "datetime"
      ],
      "functions": {
        "get_datetime_range": "(start_time: datetime, end_time: datetime, unit: TimeUnit = TimeUnit.DAYS, granularity: int = 1,) -> list[datetime]",
        "get_pairs_from_range": "(dt_range: list[datetime]) -> list[tuple[datetime, datetime]]"
      },
      "classes": {},
      "call_graph": {},
      "enums": {
        "TimeUnit": {
          "values": [
            "SECONDS",
            "MINUTES",
            "HOURS",
            "DAYS"
          ],
          "doc": ""
        },
        "BQTimeUnit": {
          "values": [
            "MINUTE",
            "HOUR",
            "DAY"
          ],
          "doc": ""
        }
      }
    },
    "app\\helpers\\utils.py": {
      "language": "python",
      "parsed": true,
      "purpose": "Utility functions",
      "imports": [
        "json",
        "logging",
        "traceback",
        "concurrent.futures",
        "typing"
      ],
      "functions": {
        "dump_json": "(x)",
        "get_trace": {
          "signature": "(e: Exception, n: int = 5)",
          "called_by": [
            "run_parallel_exec",
            "run_functions_in_parallel"
          ]
        },
        "run_parallel_exec": {
          "calls": [
            "get_trace"
          ],
          "signature": "(exec_func: Callable, iterable: Iterable, *func_args, **kwargs)",
          "called_by": [
            "run_parallel_exec_but_return_in_order"
          ]
        },
        "run_parallel_exec_but_return_in_order": {
          "calls": [
            "run_parallel_exec"
          ],
          "signature": "(exec_func: Callable, iterable: Iterable, *func_args, **kwargs)"
        },
        "run_functions_in_parallel": {
          "calls": [
            "get_trace",
            "pool_executor"
          ],
          "signature": "(functions: List[Callable], max_workers: int = 100, parallelism: Literal[\"thread\", \"process\"] = \"thread\", prefix: str = \"unknown\", quiet: bool = False,)"
        },
        "chunkify": "(lst: list, chunk_size: int = 40)",
        "clean_name": "(name: str, replacements: dict[str, str] = {}, replace_dot_with_next_capital: bool = True,)"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\helpers\\__init__.py": {
      "language": "python",
      "parsed": false
    },
    "app\\logic\\trips.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "typing",
        "datetime",
        "pandas",
        "pandas_gbq",
        "fastapi",
        "helpers.time_utils",
        "helpers.agy_utils",
        "utils.weather_api"
      ],
      "functions": {
        "get_trailer_and_trips": "()",
        "get_trip_data": "(trailer_id: str, trip_id: str)",
        "add_weather_data_to_grouped_alerts": {
          "signature": "(df: pd.DataFrame, bt: BackgroundTasks = None) -> pd.DataFrame",
          "called_by": [
            "fetch_latest_alerts"
          ]
        },
        "fetch_latest_alerts": {
          "calls": [
            "add_weather_data_to_grouped_alerts"
          ],
          "signature": "(value: int, unit: BQTimeUnit, bt: BackgroundTasks = None) -> dict[str, Any]"
        }
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\logic\\weather.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "httpx",
        "typing",
        "config"
      ],
      "functions": {},
      "classes": {
        "WeatherService": {
          "methods": {
            "get_current_weather": {
              "decorators": [
                "staticmethod"
              ],
              "signature": "async (location: str, aqi: bool = False) -> Dict[str, Any]",
              "called_by": [
                "get_current_weather"
              ]
            }
          },
          "properties": [
            "location",
            "aqi"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\logic\\__init__.py": {
      "language": "python",
      "parsed": false
    },
    "app\\models\\alert_filter.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "datetime",
        "enum",
        "typing",
        "sqlmodel",
        "pydantic",
        "helpers.agy_utils"
      ],
      "functions": {},
      "classes": {
        "AlertFilterUpdate": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "properties": [
            "exclude",
            "description"
          ]
        },
        "AlertFilterCreate": {
          "methods": {
            "validate_id_type": {
              "decorators": [
                "field_validator",
                "classmethod"
              ],
              "signature": "(cls, value)"
            },
            "validate_id": {
              "decorators": [
                "model_validator"
              ],
              "signature": "(self)"
            }
          },
          "inherits": [
            "AlertFilterUpdate"
          ],
          "properties": [
            "entity_id",
            "id_type"
          ]
        },
        "AlertFilter": {
          "methods": {},
          "inherits": [
            "AlertFilterCreate",
            "table=True"
          ],
          "properties": [
            "id",
            "created_at",
            "updated_at"
          ]
        }
      },
      "call_graph": {},
      "enums": {
        "MuteEnum": {
          "values": [
            "MUTE",
            "UNMUTE"
          ],
          "doc": ""
        }
      }
    },
    "app\\models\\drivers.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "sqlmodel",
        "pydantic",
        "db",
        "helpers"
      ],
      "functions": {},
      "classes": {
        "Driver": {
          "methods": {
            "get_session": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a database session",
              "signature": "(cls) -> Session",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "get_all": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get all drivers from the database",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, limit: int = 5000) -> List[\"Driver\"]"
            },
            "get_by_id": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get a driver by ID",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, driver_id: str) -> Optional[\"Driver\"]",
              "called_by": [
                "Driver.upsert",
                "ActiveLoadTracking.upsert"
              ]
            },
            "get_by_ids": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get multiple drivers by their IDs in a single query",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, driver_ids: List[str]) -> List[\"Driver\"]",
              "called_by": [
                "Driver.bulk_upsert"
              ]
            },
            "get_by_telegram_id": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get a driver by telegram ID",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, telegram_id: str) -> Optional[\"Driver\"]"
            },
            "upsert": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Upsert a single driver (insert or update if exists) - only updates provided fields",
              "calls": [
                "get_by_id",
                "get_session"
              ],
              "signature": "(cls, driver_data: \"DriverCallUpdate\") -> Optional[\"Driver\"]"
            },
            "bulk_upsert": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Bulk upsert multiple drivers - only updates provided fields",
              "calls": [
                "_execute_single_upsert",
                "get_by_ids",
                "get_session"
              ],
              "signature": "(cls, drivers_data: List[\"DriverCallUpdate\"]) -> List[\"Driver\"]"
            },
            "_execute_single_upsert": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Helper method to execute a single upsert within an existing session",
              "signature": "(cls, session, driver_data: \"DriverCallUpdate\")",
              "called_by": [
                "Driver.bulk_upsert"
              ]
            },
            "bulk_update_calling_info": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Bulk update driver calling information",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, updates: List[\"DriverCallUpdate\"]) -> None"
            }
          },
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "driverId",
            "status",
            "firstName",
            "lastName",
            "truckId",
            "phoneNumber",
            "email",
            "hiredOn",
            "updatedOn",
            "companyId",
            "dispatcher",
            "firstLanguage",
            "secondLanguage",
            "globalDnd",
            "safetyCall",
            "safetyMessage",
            "hosSupport",
            "maintainanceCall",
            "maintainanceMessage",
            "dispatchCall",
            "dispatchMessage",
            "accountCall",
            "accountMessage",
            "telegramId"
          ]
        },
        "DriverResponse": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "doc": "Response model for cleaned driver data",
          "properties": [
            "driverId",
            "status",
            "firstName",
            "lastName",
            "truckId",
            "phoneNumber",
            "email",
            "hiredOn",
            "updatedOn",
            "companyId",
            "dispatcher",
            "firstLanguage",
            "secondLanguage",
            "globalDnd",
            "safetyCall",
            "safetyMessage",
            "hosSupport",
            "maintainanceCall",
            "maintainanceMessage",
            "dispatchCall",
            "dispatchMessage",
            "accountCall",
            "accountMessage",
            "telegramId"
          ]
        },
        "DriverCallUpdate": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "doc": "Model for driver call updates",
          "properties": [
            "driverId",
            "status",
            "firstName",
            "lastName",
            "truckId",
            "phoneNumber",
            "email",
            "hiredOn",
            "updatedOn",
            "companyId",
            "dispatcher",
            "firstLanguage",
            "secondLanguage",
            "globalDnd",
            "safetyCall",
            "safetyMessage",
            "hosSupport",
            "maintainanceCall",
            "maintainanceMessage",
            "dispatchCall",
            "dispatchMessage",
            "accountCall",
            "accountMessage",
            "telegramId"
          ]
        },
        "CreateDriverRequest": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "firstName",
            "lastName",
            "phoneNumber",
            "status",
            "truckId",
            "email",
            "hiredOn",
            "companyId",
            "dispatcher",
            "firstLanguage",
            "secondLanguage",
            "globalDnd",
            "safetyCall",
            "safetyMessage",
            "hosSupport",
            "maintainanceCall",
            "maintainanceMessage",
            "dispatchCall",
            "dispatchMessage",
            "accountCall",
            "accountMessage",
            "telegramId"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\models\\driver_data.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "sqlmodel",
        "db",
        "logging",
        "utils.vapi_client",
        "models.vapi",
        "config",
        "httpx",
        "fastapi",
        "models.driver_model_prompt",
        "traceback",
        "models.trips",
        "random",
        "models.vapi",
        "models.vapi",
        "traceback",
        "json",
        "traceback"
      ],
      "functions": {
        "get_driver_summary": {
          "calls": [
            "get_by_driver",
            "get_by_trip",
            "get_by_trip_id"
          ],
          "signature": "(driver_id: str) -> Dict"
        },
        "get_trip_data_for_violations": {
          "calls": [
            "get_by_trip",
            "get_by_trip_id"
          ],
          "signature": "(trip_id: str, driver_id: str) -> Dict",
          "called_by": [
            "generate_prompt_for_driver"
          ]
        },
        "get_prompt_from_db": {
          "doc": "Fetch a prompt from the database by name",
          "signature": "(prompt_name: str) -> Optional[DriverPrompts]",
          "called_by": [
            "build_reminder_prompt",
            "build_temperature_violation_prompt",
            "build_out_of_route_prompt",
            "build_stopping_200_miles_prompt",
            "build_fuel_violation_prompt",
            "build_trailer_check_prompt",
            "generate_enhanced_conversational_prompt"
          ]
        },
        "map_description_to_prompt_name": {
          "signature": "(description: str) -> Optional[str]",
          "called_by": [
            "build_reminder_prompt",
            "generate_enhanced_conversational_prompt"
          ]
        },
        "build_reminder_prompt": {
          "calls": [
            "get_prompt_from_db",
            "map_description_to_prompt_name"
          ],
          "signature": "(violation_type: str, violation_description: str) -> str",
          "called_by": [
            "generate_enhanced_conversational_prompt"
          ]
        },
        "build_temperature_violation_prompt": {
          "calls": [
            "get_prompt_from_db"
          ],
          "signature": "(trip_data: Dict) -> str",
          "called_by": [
            "generate_enhanced_conversational_prompt"
          ]
        },
        "build_out_of_route_prompt": {
          "calls": [
            "get_prompt_from_db"
          ],
          "signature": "(trip_data: Dict) -> str",
          "called_by": [
            "generate_enhanced_conversational_prompt"
          ]
        },
        "build_stopping_200_miles_prompt": {
          "calls": [
            "get_prompt_from_db"
          ],
          "signature": "(trip_data: Dict) -> str",
          "called_by": [
            "generate_enhanced_conversational_prompt"
          ]
        },
        "build_fuel_violation_prompt": {
          "calls": [
            "get_prompt_from_db"
          ],
          "signature": "(trip_data: Dict) -> str",
          "called_by": [
            "generate_enhanced_conversational_prompt"
          ]
        },
        "build_trailer_check_prompt": {
          "calls": [
            "get_prompt_from_db"
          ],
          "signature": "(trip_data: Dict) -> str",
          "called_by": [
            "generate_enhanced_conversational_prompt"
          ]
        },
        "generate_enhanced_conversational_prompt": {
          "calls": [
            "build_fuel_violation_prompt",
            "build_out_of_route_prompt",
            "build_reminder_prompt",
            "build_stopping_200_miles_prompt",
            "build_temperature_violation_prompt",
            "build_trailer_check_prompt",
            "get_prompt_from_db",
            "map_description_to_prompt_name"
          ],
          "signature": "(driver_name: str, violations: List, reminders: List = None, trip_data: Dict = None, custom_rules: str = None) -> str",
          "called_by": [
            "generate_prompt_for_driver"
          ]
        },
        "categorize_violations": "(violations: List) -> tuple",
        "generate_conversational_prompt": "(driver_name: str, violations: List, custom_rules: str = \"\") -> str",
        "generate_prompt_for_driver": {
          "calls": [
            "generate_enhanced_conversational_prompt",
            "get_latest_by_driver",
            "get_trip_data_for_violations"
          ],
          "signature": "async (request)"
        },
        "make_drivers_violation_batch_call": "async (request: BatchCallRequest)"
      },
      "classes": {
        "DriverTripData": {
          "methods": {
            "get_session": {
              "decorators": [
                "classmethod"
              ],
              "signature": "(cls) -> Session",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "get_all": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Fetch all trips",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, limit: int = 5000) -> List[\"DriverTripData\"]"
            },
            "get_by_driver": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get the latest trip for a driver (no specific ordering)",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, driver_id: str) -> Optional[\"DriverTripData\"]",
              "called_by": [
                "get_driver_summary"
              ]
            },
            "get_latest_by_driver": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get the most recent/active trip for a driver",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, driver_id: str) -> Optional[\"DriverTripData\"]",
              "called_by": [
                "generate_prompt_for_driver"
              ]
            },
            "get_by_trip": {
              "decorators": [
                "classmethod"
              ],
              "calls": [
                "get_session"
              ],
              "signature": "(cls, trip_id: str) -> Optional[\"DriverTripData\"]",
              "called_by": [
                "get_by_trip",
                "get_driver_combined",
                "get_trip_data_for_violations",
                "get_driver_summary"
              ]
            }
          },
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "tripId",
            "primaryDriverId",
            "fuelPercent",
            "outOfRoute",
            "ditatSetPoint",
            "tempC",
            "tempF",
            "etaTimeDifference",
            "trlCheck",
            "onTimeStatus",
            "subStatusLabel"
          ]
        },
        "ActiveLoadTracking": {
          "methods": {
            "get_session": {
              "decorators": [
                "classmethod"
              ],
              "signature": "(cls) -> Session",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "get_all": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Fetch all active load tracking rows",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, limit: int = 5000) -> List[\"ActiveLoadTracking\"]"
            },
            "get_by_trip": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Fetch active load by tripId",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, trip_id: str) -> Optional[\"ActiveLoadTracking\"]",
              "called_by": [
                "get_by_trip",
                "get_driver_combined",
                "get_trip_data_for_violations",
                "get_driver_summary"
              ]
            }
          },
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "load_id",
            "trip_id",
            "miles_threshold",
            "driver_name",
            "status",
            "driver_phone_number",
            "start_time",
            "start_odometer_miles",
            "current_odometer_miles"
          ]
        },
        "ViolationAlertDriver": {
          "methods": {
            "get_session": {
              "decorators": [
                "classmethod"
              ],
              "signature": "(cls) -> Session",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "get_all": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Fetch all vilation alerts",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, limit: int = 5000) -> List[\"ViolationAlertDriver\"]"
            },
            "get_by_trip_id": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Fetch violation by id",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, trip_id: str) -> Optional[\"ViolationAlertDriver\"]",
              "called_by": [
                "Trip.upsert",
                "get_trip_data_for_violations",
                "get_driver_summary"
              ]
            }
          },
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "id",
            "load_id",
            "violation_time"
          ]
        }
      },
      "constants": {
        "DATA_DRIVEN_VIOLATIONS": "collection",
        "REMINDER_VIOLATIONS": "collection",
        "SYSTEM_PROMPT": "str"
      },
      "call_graph": {}
    },
    "app\\models\\driver_mapping.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "sqlmodel",
        "db",
        "helpers"
      ],
      "functions": {},
      "classes": {
        "DriverMapping": {
          "methods": {
            "get_session": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a database session",
              "signature": "(cls) -> Session",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "get_with_filters": {
              "decorators": [
                "classmethod"
              ],
              "calls": [
                "get_session"
              ],
              "signature": "(cls, driverid: Optional[str] = None, driverkey: Optional[str] = None, driverfullname: Optional[str] = None, limit: int = 100, offset: int = 0, sort: Optional[str] = None) -> Dict[str, Any]"
            },
            "get_by_driverid": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get a driver mapping by driverid",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, driverid: str) -> Optional[\"DriverMapping\"]"
            },
            "get_by_driverkey": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get all driver mappings by driverkey",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, driverkey: str) -> List[\"DriverMapping\"]"
            },
            "create": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a new driver mapping",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, driverid: str, driverkey: Optional[str] = None, driverfullname: Optional[str] = None) -> Optional[\"DriverMapping\"]"
            },
            "update": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Update an existing driver mapping",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, driverid: str, driverkey: Optional[str] = None, driverfullname: Optional[str] = None) -> Optional[\"DriverMapping\"]"
            },
            "delete": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Delete a driver mapping",
              "calls": [
                "delete",
                "get_session"
              ],
              "signature": "(cls, driverid: str) -> bool",
              "called_by": [
                "ActiveLoadTracking.delete",
                "TrailerUnitMapping.delete",
                "DispatchedTrip.delete",
                "TempSensorMapping.delete",
                "Trip.truncate_table",
                "Trip.delete",
                "ViolationAlert.delete",
                "DispatchedTrip.delete_by_trip_key",
                "DriverMapping.delete",
                "TruckMapping.delete"
              ]
            }
          },
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "driverid",
            "driverkey",
            "driverfullname",
            "driverid",
            "driverkey",
            "driverfullname",
            "limit",
            "offset",
            "sort"
          ]
        },
        "DriverMappingCreate": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "doc": "Schema for creating a driver mapping",
          "properties": [
            "driverid",
            "driverkey",
            "driverfullname"
          ]
        },
        "DriverMappingUpdate": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "doc": "Schema for updating a driver mapping",
          "properties": [
            "driverkey",
            "driverfullname"
          ]
        },
        "DriverMappingResponse": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "doc": "Response schema for driver mapping queries",
          "properties": [
            "driverid",
            "driverkey",
            "driverfullname"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\models\\driver_model_prompt.py": {
      "language": "python",
      "parsed": true,
      "purpose": "Data model",
      "imports": [
        "typing",
        "datetime",
        "sqlmodel",
        "uuid"
      ],
      "functions": {},
      "classes": {
        "DriverPrompts": {
          "methods": {},
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "id",
            "prompt_name",
            "condition_true_prompt",
            "condition_false_prompt",
            "description",
            "last_modified",
            "created_at"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\models\\driver_reports.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "datetime",
        "sqlmodel",
        "db",
        "helpers"
      ],
      "functions": {},
      "classes": {
        "DriverReport": {
          "methods": {
            "get_session": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a database session",
              "signature": "(cls) -> Session",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "get_all": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get all driver reports",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, limit: int = 1000) -> list[\"DriverReport\"]"
            },
            "get_by_trip_id": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get report by trip ID",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, trip_id: str) -> Optional[\"DriverReport\"]",
              "called_by": [
                "Trip.upsert",
                "get_trip_data_for_violations",
                "get_driver_summary"
              ]
            }
          },
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "id",
            "tripId",
            "dispatcherName",
            "driverIdPrimary",
            "driverIdSecondary",
            "Calculation",
            "onTimeStatus",
            "eta",
            "pickupTime",
            "deliveryTime",
            "milesRemaining",
            "gpsSpeed",
            "currentLocation",
            "destinationCity",
            "destinationState",
            "etaNotes",
            "loadingCity",
            "loadingState",
            "arrivedLoading",
            "departedLoading",
            "arrivedDelivery",
            "leftDelivery",
            "deliveryLateAfterTime",
            "tripStatusText",
            "subStatus",
            "driverFeeling",
            "driverName",
            "onTime",
            "driverETAfeedback",
            "delayReason",
            "additionalDriverNotes",
            "slackPosted",
            "callStatus",
            "reportDate",
            "createdAt",
            "updatedAt"
          ]
        },
        "DriverMorningReport": {
          "methods": {
            "get_session": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a database session",
              "signature": "(cls) -> Session",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "get_all": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get all morning reports",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, limit: int = 1000) -> list[\"DriverMorningReport\"]"
            },
            "get_by_driver_id": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get morning report by driver ID",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, driver_id: str) -> Optional[\"DriverMorningReport\"]"
            }
          },
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "id",
            "tripId",
            "dispatcherName",
            "driverIdPrimary",
            "MPH",
            "MilesLEFT",
            "Location2",
            "currentLocation",
            "AI_ETA",
            "loadingCity",
            "loadingState",
            "destinationCity",
            "destinationState",
            "pickupTime",
            "deliveryTime",
            "DeliveryLATEAfterTime",
            "arrivedLoading",
            "departedLoading",
            "Ditat_ETA",
            "ETA_NOTES",
            "arrivedDelivery",
            "leftDelivery",
            "tripStatusText",
            "subStatus",
            "driverFeeling",
            "driverName",
            "onTime",
            "driverETAfeedback",
            "delayReason",
            "additionalDriverNotes",
            "slackPosted",
            "callStatus",
            "reportDate",
            "ETA_Notes_1",
            "workflowTrigger",
            "loadGroup",
            "createdAt",
            "updatedAt"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\models\\driver_triggers.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "sqlmodel",
        "db",
        "logging",
        "fastapi",
        "httpx",
        "config"
      ],
      "functions": {
        "make_vapi_call": "async (driver_data: dict)"
      },
      "classes": {
        "ActiveLoadTracking": {
          "methods": {},
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "load_id",
            "trip_id",
            "miles_threshold"
          ]
        },
        "DriverTriggersData": {
          "methods": {
            "get_session": {
              "decorators": [
                "classmethod"
              ],
              "signature": "(cls) -> Session",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "get_trip_by_driver_id": {
              "decorators": [
                "classmethod"
              ],
              "calls": [
                "get_session"
              ],
              "signature": "(cls, driver_id: str) -> Optional[\"DriverTriggersData\"]",
              "called_by": [
                "DriverTriggersData.get_driver_trigger"
              ]
            },
            "get_active_load_by_trip": {
              "decorators": [
                "staticmethod"
              ],
              "signature": "(trip_id: str) -> Optional[ActiveLoadTracking]",
              "called_by": [
                "DriverTriggersData.get_driver_trigger"
              ]
            },
            "get_driver_trigger": {
              "decorators": [
                "classmethod"
              ],
              "calls": [
                "get_active_load_by_trip",
                "get_trip_by_driver_id"
              ],
              "signature": "(cls, payload: Dict) -> Dict[str, List[str]]"
            }
          },
          "class_constants": {
            "SET_FUEL": "number"
          },
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "tripId",
            "primaryDriverId",
            "fuelPercent",
            "outOfRoute",
            "tempC",
            "tempF",
            "trlCheck",
            "onTimeStatus"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\models\\load_tracking.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "datetime",
        "decimal",
        "sqlmodel",
        "pydantic",
        "db",
        "helpers"
      ],
      "functions": {},
      "classes": {
        "ActiveLoadTracking": {
          "methods": {
            "get_session": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a database session",
              "signature": "(cls) -> Session",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "get_all": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get all active load tracking records",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, limit: int = 5000, sort_by: str = \"created_at\", sort_order: str = \"desc\") -> List[\"ActiveLoadTracking\"]"
            },
            "get_by_id": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get an active load tracking record by ID",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, load_id: str) -> Optional[\"ActiveLoadTracking\"]",
              "called_by": [
                "Driver.upsert",
                "ActiveLoadTracking.upsert"
              ]
            },
            "get_by_status": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get active load tracking records by status",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, status_filter: str, limit: int = 5000, sort_by: str = \"created_at\", sort_order: str = \"desc\",) -> List[\"ActiveLoadTracking\"]"
            },
            "get_by_created_at": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get active load tracking records by created_at date (YYYY-MM-DD format)",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, created_at_date: str, limit: int = 5000, sort_by: str = \"created_at\", sort_order: str = \"desc\",) -> List[\"ActiveLoadTracking\"]"
            },
            "create": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a new active load tracking record",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, record_data: \"ActiveLoadTrackingCreate\") -> Optional[\"ActiveLoadTracking\"]"
            },
            "update": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Update an active load tracking record",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, load_id: str, record_data: \"ActiveLoadTrackingUpdate\") -> Optional[\"ActiveLoadTracking\"]"
            },
            "delete": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Delete an active load tracking record",
              "calls": [
                "delete",
                "get_session"
              ],
              "signature": "(cls, load_id: str) -> bool",
              "called_by": [
                "ActiveLoadTracking.delete",
                "TrailerUnitMapping.delete",
                "DispatchedTrip.delete",
                "TempSensorMapping.delete",
                "Trip.truncate_table",
                "Trip.delete",
                "ViolationAlert.delete",
                "DispatchedTrip.delete_by_trip_key",
                "DriverMapping.delete",
                "TruckMapping.delete"
              ]
            },
            "get_by_mute_flag": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get active load tracking records by mute_flag",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, mute_flag: bool, limit: int = 5000, sort_by: str = \"created_at\", sort_order: str = \"desc\",) -> List[\"ActiveLoadTracking\"]"
            },
            "update_mute_flag_by_trip_id": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Update mute_flag for an active load tracking record by trip_id",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, trip_id: str, mute_flag: bool) -> Optional[\"ActiveLoadTracking\"]"
            },
            "upsert": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Upsert an active load tracking record (insert or update if exists)",
              "calls": [
                "get_by_id",
                "get_session"
              ],
              "signature": "(cls, record_data: \"ActiveLoadTrackingUpsert\") -> Optional[\"ActiveLoadTracking\"]"
            }
          },
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "load_id",
            "trip_id",
            "vehicle_id",
            "driver_name",
            "driver_phone_number",
            "truck_unit",
            "start_time",
            "start_odometer_miles",
            "current_odometer_miles",
            "miles_threshold",
            "current_stop_start",
            "total_distance_traveled",
            "last_alert_sent",
            "last_known_lat",
            "last_known_lng",
            "status",
            "violation_resolved",
            "mute_flag",
            "created_at",
            "updated_at"
          ]
        },
        "ActiveLoadTrackingCreate": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "load_id",
            "trip_id",
            "vehicle_id",
            "driver_name",
            "driver_phone_number",
            "truck_unit",
            "start_time",
            "start_odometer_miles",
            "current_odometer_miles",
            "miles_threshold",
            "current_stop_start",
            "total_distance_traveled",
            "last_alert_sent",
            "last_known_lat",
            "last_known_lng",
            "status",
            "violation_resolved",
            "mute_flag"
          ]
        },
        "ActiveLoadTrackingUpdate": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "trip_id",
            "vehicle_id",
            "driver_name",
            "driver_phone_number",
            "truck_unit",
            "start_time",
            "start_odometer_miles",
            "current_odometer_miles",
            "miles_threshold",
            "current_stop_start",
            "total_distance_traveled",
            "last_alert_sent",
            "last_known_lat",
            "last_known_lng",
            "status",
            "violation_resolved",
            "mute_flag"
          ]
        },
        "ActiveLoadTrackingUpsert": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "load_id",
            "trip_id",
            "vehicle_id",
            "driver_name",
            "driver_phone_number",
            "truck_unit",
            "start_time",
            "start_odometer_miles",
            "current_odometer_miles",
            "miles_threshold",
            "current_stop_start",
            "total_distance_traveled",
            "last_alert_sent",
            "last_known_lat",
            "last_known_lng",
            "status",
            "violation_resolved",
            "mute_flag"
          ]
        },
        "ViolationAlert": {
          "methods": {
            "get_session": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a database session",
              "signature": "(cls) -> Session",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "get_all": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get all violation alerts",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, limit: int = 5000, sort_by: str = \"created_at\", sort_order: str = \"desc\") -> List[\"ViolationAlert\"]"
            },
            "get_by_id": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get a violation alert by ID",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, record_id: int) -> Optional[\"ViolationAlert\"]",
              "called_by": [
                "Driver.upsert",
                "ActiveLoadTracking.upsert"
              ]
            },
            "get_by_created_at": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get violation alerts by created_at date (YYYY-MM-DD format)",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, created_at_date: str, limit: int = 5000, sort_by: str = \"created_at\", sort_order: str = \"desc\",) -> List[\"ViolationAlert\"]"
            },
            "create": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a new violation alert",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, record_data: \"ViolationAlertCreate\") -> Optional[\"ViolationAlert\"]"
            },
            "update": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Update a violation alert",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, record_id: int, record_data: \"ViolationAlertUpdate\") -> Optional[\"ViolationAlert\"]"
            },
            "delete": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Delete a violation alert",
              "calls": [
                "delete",
                "get_session"
              ],
              "signature": "(cls, record_id: int) -> bool",
              "called_by": [
                "ActiveLoadTracking.delete",
                "TrailerUnitMapping.delete",
                "DispatchedTrip.delete",
                "TempSensorMapping.delete",
                "Trip.truncate_table",
                "Trip.delete",
                "ViolationAlert.delete",
                "DispatchedTrip.delete_by_trip_key",
                "DriverMapping.delete",
                "TruckMapping.delete"
              ]
            },
            "upsert": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Upsert a violation alert (insert or update if exists)",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, record_data: \"ViolationAlertUpsert\") -> Optional[\"ViolationAlert\"]"
            }
          },
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "id",
            "load_id",
            "vehicle_id",
            "violation_time",
            "location_lat",
            "location_lng",
            "location",
            "distance_traveled_miles",
            "current_odometer_miles",
            "stop_duration_minutes",
            "current_speed",
            "alert_sent_to_slack",
            "created_at"
          ]
        },
        "ViolationAlertCreate": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "load_id",
            "vehicle_id",
            "violation_time",
            "location_lat",
            "location_lng",
            "location",
            "distance_traveled_miles",
            "current_odometer_miles",
            "stop_duration_minutes",
            "current_speed",
            "alert_sent_to_slack",
            "created_at"
          ]
        },
        "ViolationAlertUpdate": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "load_id",
            "vehicle_id",
            "violation_time",
            "location_lat",
            "location_lng",
            "location",
            "distance_traveled_miles",
            "current_odometer_miles",
            "stop_duration_minutes",
            "current_speed",
            "alert_sent_to_slack",
            "created_at"
          ]
        },
        "ViolationAlertUpsert": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "id",
            "load_id",
            "vehicle_id",
            "violation_time",
            "location_lat",
            "location_lng",
            "location",
            "distance_traveled_miles",
            "current_odometer_miles",
            "stop_duration_minutes",
            "current_speed",
            "alert_sent_to_slack",
            "created_at"
          ]
        },
        "DispatchedTrip": {
          "methods": {
            "get_session": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a database session",
              "signature": "(cls) -> Session",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "get_all": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get all dispatched trips",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, limit: int = 5000, sort_by: str = \"created_on\", sort_order: str = \"desc\") -> List[\"DispatchedTrip\"]"
            },
            "get_by_id": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get a dispatched trip by trip_id",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, trip_id: str) -> Optional[\"DispatchedTrip\"]",
              "called_by": [
                "Driver.upsert",
                "ActiveLoadTracking.upsert"
              ]
            },
            "create": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a new dispatched trip",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, record_data: \"DispatchedTripCreate\") -> Optional[\"DispatchedTrip\"]"
            },
            "update": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Update a dispatched trip",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, trip_id: str, record_data: \"DispatchedTripUpdate\") -> Optional[\"DispatchedTrip\"]"
            },
            "delete": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Delete a dispatched trip",
              "calls": [
                "delete",
                "get_session"
              ],
              "signature": "(cls, trip_id: str) -> bool",
              "called_by": [
                "ActiveLoadTracking.delete",
                "TrailerUnitMapping.delete",
                "DispatchedTrip.delete",
                "TempSensorMapping.delete",
                "Trip.truncate_table",
                "Trip.delete",
                "ViolationAlert.delete",
                "DispatchedTrip.delete_by_trip_key",
                "DriverMapping.delete",
                "TruckMapping.delete"
              ]
            },
            "delete_by_trip_key": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Delete a dispatched trip by trip_key",
              "calls": [
                "delete",
                "get_session"
              ],
              "signature": "(cls, trip_key: int) -> bool"
            },
            "upsert": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Upsert a dispatched trip (insert or update if exists)",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, record_data: \"DispatchedTripUpsert\") -> Optional[\"DispatchedTrip\"]"
            }
          },
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "id",
            "trip_key",
            "trip_id",
            "created_by",
            "created_on",
            "derived_driver_key",
            "derivedtrailerkey",
            "derivedtruckkey",
            "dispatchedby"
          ]
        },
        "DispatchedTripCreate": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "trip_key",
            "trip_id",
            "created_by",
            "created_on",
            "derived_driver_key",
            "derivedtrailerkey",
            "derivedtruckkey",
            "dispatchedby"
          ]
        },
        "DispatchedTripUpdate": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "trip_key",
            "trip_id",
            "created_by",
            "created_on",
            "derived_driver_key",
            "derivedtrailerkey",
            "derivedtruckkey",
            "dispatchedby"
          ]
        },
        "DispatchedTripUpsert": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "id",
            "trip_key",
            "trip_id",
            "created_by",
            "created_on",
            "derived_driver_key",
            "derivedtrailerkey",
            "derivedtruckkey",
            "dispatchedby"
          ]
        },
        "MuteFlagUpdateRequest": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "mute",
            "tripId"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\models\\page_access_token_model.py": {
      "language": "python",
      "parsed": true,
      "purpose": "Data model",
      "imports": [
        "typing",
        "datetime",
        "sqlmodel",
        "uuid"
      ],
      "functions": {},
      "classes": {
        "PageAccessTokens": {
          "methods": {},
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "id",
            "page_name",
            "page_url",
            "description",
            "category",
            "page_access_token",
            "filter",
            "created_at"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\models\\pcmiler.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "pydantic"
      ],
      "functions": {},
      "classes": {
        "ETARequest": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "origin",
            "destination",
            "departureTime"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\models\\slack.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "enum",
        "pydantic",
        "requests",
        "config"
      ],
      "functions": {},
      "classes": {
        "MDText": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "doc": "Slack markdown text object",
          "properties": [
            "text",
            "type"
          ]
        },
        "PlainText": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "doc": "Slack plain text object",
          "properties": [
            "text",
            "emoji",
            "type"
          ]
        },
        "Image": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "doc": "Slack image object",
          "properties": [
            "image_url",
            "alt_text",
            "type"
          ]
        },
        "Button": {
          "methods": {
            "validate_text_type": {
              "decorators": [
                "field_validator",
                "classmethod"
              ],
              "signature": "(cls, value)"
            }
          },
          "inherits": [
            "BaseModel"
          ],
          "doc": "Slack button object",
          "properties": [
            "text",
            "action_id",
            "value",
            "style",
            "url",
            "type"
          ]
        },
        "Option": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "value",
            "text"
          ]
        },
        "MultiSelect": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "placeholder",
            "options",
            "action_id",
            "type"
          ]
        },
        "DividerBlock": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "type"
          ]
        },
        "SectionBlock": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "text",
            "accessory",
            "type"
          ]
        },
        "HeaderBlock": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "text",
            "type"
          ]
        },
        "ContextBlock": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "elements",
            "type"
          ]
        },
        "ActionsBlock": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "elements",
            "type"
          ]
        },
        "Payload": {
          "methods": {
            "post": {
              "calls": [
                "post"
              ],
              "signature": "(self) -> dict[str, str | int]",
              "called_by": [
                "Payload.post"
              ]
            }
          },
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "channel",
            "blocks",
            "text",
            "user"
          ]
        }
      },
      "call_graph": {},
      "enums": {
        "ButtonStyle": {
          "values": [
            "PRIMARY",
            "DANGER"
          ],
          "doc": "Slack button styles"
        }
      }
    },
    "app\\models\\temp_sensor_mapping.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "sqlmodel",
        "db",
        "helpers",
        "sqlalchemy",
        "sqlalchemy",
        "sqlalchemy"
      ],
      "functions": {},
      "classes": {
        "TempSensorMapping": {
          "methods": {
            "get_session": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a database session",
              "signature": "(cls) -> Session",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "get_all": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get all temp sensor mappings from the database",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, limit: int = 5000) -> List[\"TempSensorMapping\"]"
            },
            "get_by_sensor_name": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get a temp sensor mapping by TempSensorNAME (case-insensitive)",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, sensor_name: str) -> Optional[\"TempSensorMapping\"]",
              "called_by": [
                "TempSensorMapping.upsert"
              ]
            },
            "get_by_sensor_id": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get all temp sensor mappings by TempSensorID",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, sensor_id: int) -> List[\"TempSensorMapping\"]"
            },
            "create": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a new temp sensor mapping",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, sensor_name: str, sensor_id: Optional[int] = None) -> Optional[\"TempSensorMapping\"]"
            },
            "update": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Update an existing temp sensor mapping (case-insensitive search)",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, sensor_name: str, sensor_id: Optional[int] = None) -> Optional[\"TempSensorMapping\"]"
            },
            "upsert": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Upsert a temp sensor mapping (insert or update if exists) - only updates provided fields",
              "calls": [
                "get_by_sensor_name",
                "get_session"
              ],
              "signature": "(cls, sensor_name: str, sensor_id: Optional[int] = None) -> Optional[\"TempSensorMapping\"]"
            },
            "delete": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Delete a temp sensor mapping (case-insensitive search)",
              "calls": [
                "delete",
                "get_session"
              ],
              "signature": "(cls, sensor_name: str) -> bool",
              "called_by": [
                "ActiveLoadTracking.delete",
                "TrailerUnitMapping.delete",
                "DispatchedTrip.delete",
                "TempSensorMapping.delete",
                "Trip.truncate_table",
                "Trip.delete",
                "ViolationAlert.delete",
                "DispatchedTrip.delete_by_trip_key",
                "DriverMapping.delete",
                "TruckMapping.delete"
              ]
            }
          },
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "TempSensorNAME",
            "TempSensorID"
          ]
        },
        "TempSensorMappingCreate": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "doc": "Schema for creating a temp sensor mapping",
          "properties": [
            "TempSensorNAME",
            "TempSensorID"
          ]
        },
        "TempSensorMappingUpdate": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "doc": "Schema for updating a temp sensor mapping",
          "properties": [
            "TempSensorID"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\models\\test_modal.py": {
      "language": "python",
      "parsed": true,
      "purpose": "Test file",
      "imports": [
        "pydantic",
        "typing",
        "logging"
      ],
      "functions": {
        "get_all_books": {
          "calls": [
            "fake_books"
          ],
          "signature": "() -> list[TestBook]"
        },
        "get_id_book": {
          "calls": [
            "fake_books"
          ],
          "signature": "(book_id: int) -> TestBook | None"
        }
      },
      "classes": {
        "TestBook": {
          "methods": {
            "fake_books": {
              "decorators": [
                "classmethod"
              ],
              "signature": "(cls) -> List[\"TestBook\"]",
              "called_by": [
                "get_all_books",
                "get_id_book"
              ]
            }
          },
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "id",
            "title",
            "author"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\models\\trailer_unit_mapping.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "sqlmodel",
        "db",
        "helpers"
      ],
      "functions": {},
      "classes": {
        "TrailerUnitMapping": {
          "methods": {
            "get_session": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a database session",
              "signature": "(cls) -> Session",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "get_all": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get all trailer unit mappings from the database",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, limit: int = 5000) -> List[\"TrailerUnitMapping\"]"
            },
            "get_by_trailer_unit": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get a trailer unit mapping by TrailerUnit",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, trailer_unit: str) -> Optional[\"TrailerUnitMapping\"]",
              "called_by": [
                "TrailerUnitMapping.upsert"
              ]
            },
            "get_by_trailer_id": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get all trailer unit mappings by TrailerID",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, trailer_id: int) -> List[\"TrailerUnitMapping\"]"
            },
            "create": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a new trailer unit mapping",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, trailer_unit: str, trailer_id: Optional[int] = None) -> Optional[\"TrailerUnitMapping\"]"
            },
            "update": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Update an existing trailer unit mapping",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, trailer_unit: str, trailer_id: Optional[int] = None) -> Optional[\"TrailerUnitMapping\"]"
            },
            "upsert": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Upsert a trailer unit mapping (insert or update if exists) - only updates provided fields",
              "calls": [
                "get_by_trailer_unit",
                "get_session"
              ],
              "signature": "(cls, trailer_unit: str, trailer_id: Optional[int] = None) -> Optional[\"TrailerUnitMapping\"]"
            },
            "delete": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Delete a trailer unit mapping",
              "calls": [
                "delete",
                "get_session"
              ],
              "signature": "(cls, trailer_unit: str) -> bool",
              "called_by": [
                "ActiveLoadTracking.delete",
                "TrailerUnitMapping.delete",
                "DispatchedTrip.delete",
                "TempSensorMapping.delete",
                "Trip.truncate_table",
                "Trip.delete",
                "ViolationAlert.delete",
                "DispatchedTrip.delete_by_trip_key",
                "DriverMapping.delete",
                "TruckMapping.delete"
              ]
            }
          },
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "TrailerUnit",
            "TrailerID"
          ]
        },
        "TrailerUnitMappingCreate": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "doc": "Schema for creating a trailer unit mapping",
          "properties": [
            "TrailerUnit",
            "TrailerID"
          ]
        },
        "TrailerUnitMappingUpdate": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "doc": "Schema for updating a trailer unit mapping",
          "properties": [
            "TrailerID"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\models\\trips.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "datetime",
        "decimal",
        "sqlmodel",
        "db",
        "helpers"
      ],
      "functions": {},
      "classes": {
        "Trip": {
          "methods": {
            "get_session": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a database session",
              "signature": "(cls) -> Session",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "get_all": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get all trips from the database",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, limit: int = 5000) -> List[\"Trip\"]"
            },
            "get_by_trip_id": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get a trip by tripId",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, trip_id: str) -> Optional[\"Trip\"]",
              "called_by": [
                "Trip.upsert",
                "get_trip_data_for_violations",
                "get_driver_summary"
              ]
            },
            "get_by_driver_id": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get all trips by driver ID",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, driver_id: str) -> List[\"Trip\"]"
            },
            "create": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a new trip",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, **kwargs) -> Optional[\"Trip\"]"
            },
            "update": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Update an existing trip",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, trip_id: str, **kwargs) -> Optional[\"Trip\"]"
            },
            "upsert": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Upsert a trip (insert or update if exists) - only updates provided fields",
              "calls": [
                "get_by_trip_id",
                "get_session"
              ],
              "signature": "(cls, trip_id: str, **kwargs) -> Optional[\"Trip\"]"
            },
            "delete": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Delete a trip",
              "calls": [
                "delete",
                "get_session"
              ],
              "signature": "(cls, trip_id: str) -> bool",
              "called_by": [
                "ActiveLoadTracking.delete",
                "TrailerUnitMapping.delete",
                "DispatchedTrip.delete",
                "TempSensorMapping.delete",
                "Trip.truncate_table",
                "Trip.delete",
                "ViolationAlert.delete",
                "DispatchedTrip.delete_by_trip_key",
                "DriverMapping.delete",
                "TruckMapping.delete"
              ]
            },
            "truncate_table": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Truncate the trips table (delete all records)",
              "calls": [
                "delete",
                "get_session"
              ],
              "signature": "(cls) -> dict"
            }
          },
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "tripId",
            "lastModified",
            "primaryDriverId",
            "truckId",
            "fuelPercent",
            "primaryTrailerId",
            "trlCheck",
            "subStatusLabel",
            "checkCall",
            "mph",
            "milesLeft",
            "outOfRoute",
            "etaTimeDifference",
            "aiETA",
            "samsaraLocation",
            "liveSharingUrl",
            "customerName",
            "customerGroup",
            "emptyDrivingDistance",
            "loadedDrivingDistance",
            "shipperName",
            "loadingCity",
            "destinationName",
            "destinationCity",
            "puArrival",
            "puTime",
            "puTimeLatest",
            "arrivedToPU",
            "leftFromPU",
            "delArrival",
            "deliveryEarliest",
            "deliveryLatest",
            "arrivedToDelivery",
            "onTimeStatus",
            "sensorName",
            "ditatSetPoint",
            "tempC",
            "tempF",
            "reeferModeLabel",
            "ditatGpsSpeed",
            "dispatcher",
            "dispatcher"
          ]
        },
        "TripCreate": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "doc": "Schema for creating a trip",
          "properties": [
            "tripId",
            "lastModified",
            "primaryDriverId",
            "truckId",
            "fuelPercent",
            "primaryTrailerId",
            "trlCheck",
            "subStatusLabel",
            "checkCall",
            "mph",
            "milesLeft",
            "outOfRoute",
            "etaTimeDifference",
            "aiETA",
            "samsaraLocation",
            "liveSharingUrl",
            "customerName",
            "customerGroup",
            "emptyDrivingDistance",
            "loadedDrivingDistance",
            "shipperName",
            "loadingCity",
            "destinationName",
            "destinationCity",
            "puArrival",
            "puTime",
            "puTimeLatest",
            "arrivedToPU",
            "leftFromPU",
            "delArrival",
            "deliveryEarliest",
            "deliveryLatest",
            "arrivedToDelivery",
            "onTimeStatus",
            "sensorName",
            "ditatSetPoint",
            "tempC",
            "tempF",
            "reeferModeLabel",
            "ditatGpsSpeed",
            "dispatcher",
            "dispatcher"
          ]
        },
        "TripUpdate": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "doc": "Schema for updating a trip",
          "properties": [
            "lastModified",
            "primaryDriverId",
            "truckId",
            "fuelPercent",
            "primaryTrailerId",
            "trlCheck",
            "subStatusLabel",
            "checkCall",
            "mph",
            "milesLeft",
            "outOfRoute",
            "etaTimeDifference",
            "aiETA",
            "samsaraLocation",
            "liveSharingUrl",
            "customerName",
            "customerGroup",
            "emptyDrivingDistance",
            "loadedDrivingDistance",
            "shipperName",
            "loadingCity",
            "destinationName",
            "destinationCity",
            "puArrival",
            "puTime",
            "puTimeLatest",
            "arrivedToPU",
            "leftFromPU",
            "delArrival",
            "deliveryEarliest",
            "deliveryLatest",
            "arrivedToDelivery",
            "onTimeStatus",
            "sensorName",
            "ditatSetPoint",
            "tempC",
            "tempF",
            "reeferModeLabel",
            "ditatGpsSpeed",
            "dispatcher"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\models\\truck_mapping.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "sqlmodel",
        "db",
        "helpers"
      ],
      "functions": {},
      "classes": {
        "TruckMapping": {
          "methods": {
            "get_session": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a database session",
              "signature": "(cls) -> Session",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "get_all": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get all truck mappings from the database",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, limit: int = 5000) -> List[\"TruckMapping\"]"
            },
            "get_by_truck_unit": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get a truck mapping by TruckUnit",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, truck_unit: str) -> Optional[\"TruckMapping\"]",
              "called_by": [
                "TruckMapping.upsert"
              ]
            },
            "get_by_truck_id": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get all truck mappings by TruckId",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, truck_id: int) -> List[\"TruckMapping\"]"
            },
            "get_by_truck_key": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Get truck mapping by TruckKey (returns first match)",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, truck_key: str) -> Optional[\"TruckMapping\"]"
            },
            "create": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Create a new truck mapping",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, truck_unit: str, truck_id: Optional[int] = None, truck_key: Optional[str] = None) -> Optional[\"TruckMapping\"]"
            },
            "update": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Update an existing truck mapping",
              "calls": [
                "get_session"
              ],
              "signature": "(cls, truck_unit: str, truck_id: Optional[int] = None, truck_key: Optional[str] = None) -> Optional[\"TruckMapping\"]"
            },
            "upsert": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Upsert a truck mapping (insert or update if exists) - only updates provided fields",
              "calls": [
                "get_by_truck_unit",
                "get_session"
              ],
              "signature": "(cls, truck_unit: str, truck_id: Optional[int] = None, truck_key: Optional[str] = None) -> Optional[\"TruckMapping\"]"
            },
            "delete": {
              "decorators": [
                "classmethod"
              ],
              "doc": "Delete a truck mapping",
              "calls": [
                "delete",
                "get_session"
              ],
              "signature": "(cls, truck_unit: str) -> bool",
              "called_by": [
                "ActiveLoadTracking.delete",
                "TrailerUnitMapping.delete",
                "DispatchedTrip.delete",
                "TempSensorMapping.delete",
                "Trip.truncate_table",
                "Trip.delete",
                "ViolationAlert.delete",
                "DispatchedTrip.delete_by_trip_key",
                "DriverMapping.delete",
                "TruckMapping.delete"
              ]
            }
          },
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "TruckUnit",
            "TruckId",
            "TruckKey"
          ]
        },
        "TruckMappingCreate": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "doc": "Schema for creating a truck mapping",
          "properties": [
            "TruckUnit",
            "TruckId",
            "TruckKey"
          ]
        },
        "TruckMappingUpdate": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "doc": "Schema for updating a truck mapping",
          "properties": [
            "TruckId",
            "TruckKey"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\models\\user.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "datetime",
        "sqlmodel",
        "sqlalchemy",
        "enum"
      ],
      "functions": {},
      "classes": {
        "UserBase": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "properties": [
            "username",
            "email",
            "full_name",
            "phone",
            "avatar",
            "status",
            "department",
            "two_factor_enabled",
            "email_verified"
          ]
        },
        "UserCreate": {
          "methods": {},
          "inherits": [
            "UserBase"
          ],
          "properties": [
            "password",
            "role_id"
          ]
        },
        "UserUpdate": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "properties": [
            "email",
            "full_name",
            "phone",
            "avatar",
            "status",
            "department",
            "address",
            "role_id"
          ]
        },
        "UserLogin": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "properties": [
            "username",
            "password",
            "grant_type"
          ]
        },
        "User": {
          "methods": {},
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "id",
            "username",
            "email",
            "full_name",
            "phone",
            "avatar",
            "status",
            "department",
            "role",
            "allowed_pages",
            "address",
            "two_factor_enabled",
            "two_factor_secret",
            "email_verified",
            "email_verification_token",
            "password_reset_token",
            "password_reset_expires",
            "last_login_at",
            "created_at",
            "updated_at",
            "created_by",
            "deleted_at",
            "password",
            "is_active"
          ]
        },
        "UserSession": {
          "methods": {},
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "id",
            "user_id",
            "ip_address",
            "user_agent",
            "last_activity",
            "expires_at",
            "is_active",
            "created_at",
            "token_status",
            "token_jti"
          ]
        },
        "PendingEmailVerification": {
          "methods": {},
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "id",
            "username",
            "email",
            "password_hash",
            "full_name",
            "otp_code",
            "created_at",
            "expires_at"
          ]
        },
        "AuditLog": {
          "methods": {},
          "inherits": [
            "SQLModel",
            "table=True"
          ],
          "properties": [
            "id",
            "user_id",
            "user_email",
            "action",
            "resource",
            "resource_id",
            "old_values",
            "new_values",
            "ip_address",
            "user_agent",
            "status",
            "error_message",
            "timestamp"
          ]
        },
        "RoleResponse": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "properties": [
            "id",
            "name",
            "description",
            "permissions"
          ]
        },
        "UserResponse": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "properties": [
            "id",
            "username",
            "email",
            "full_name",
            "phone",
            "avatar",
            "status",
            "department",
            "role",
            "permissions",
            "two_factor_enabled",
            "email_verified",
            "last_login_at",
            "created_at",
            "updated_at"
          ]
        },
        "TokenResponse": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "properties": [
            "access_token",
            "token_type",
            "expires_in",
            "refresh_token",
            "user"
          ]
        },
        "UserStats": {
          "methods": {},
          "inherits": [
            "SQLModel"
          ],
          "properties": [
            "total_users",
            "active_users",
            "inactive_users",
            "suspended_users",
            "pending_users",
            "total_roles",
            "active_sessions",
            "recent_logins"
          ]
        }
      },
      "call_graph": {},
      "enums": {
        "UserStatus": {
          "values": [
            "ACTIVE",
            "INACTIVE",
            "SUSPENDED",
            "PENDING",
            "EMAIL_VERIFICATION_PENDING"
          ],
          "doc": ""
        },
        "AuditStatus": {
          "values": [
            "SUCCESS",
            "FAILURE"
          ],
          "doc": ""
        }
      }
    },
    "app\\models\\vapi.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "pydantic"
      ],
      "functions": {},
      "classes": {
        "ViolationDetail": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "type",
            "description"
          ]
        },
        "Violations": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "tripId",
            "violationDetails"
          ]
        },
        "DriverData": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "driverId",
            "driverName",
            "phoneNumber",
            "violations",
            "customRules"
          ]
        },
        "BatchCallRequest": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "callType",
            "timestamp",
            "drivers"
          ]
        },
        "VAPICallRequest": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "driverIds",
            "vapiData"
          ]
        },
        "VAPIData": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "tripId",
            "driverName",
            "currentLocation",
            "milesLeft",
            "speed",
            "eta",
            "deliveryTime",
            "destination",
            "loadingLocation",
            "onTimeStatus",
            "delayReason",
            "loadGroup",
            "tripStatus",
            "subStatus",
            "driverFeeling",
            "pickupTime",
            "lateAfterTime",
            "additionalNotes"
          ]
        },
        "DriverCallInsightsUpdate": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "driverId",
            "tripId",
            "currentLocation",
            "milesRemaining",
            "eta",
            "onTimeStatus",
            "delayReason",
            "driverMood",
            "preferredCallbackTime",
            "wantsTextInstead",
            "recordingUrl",
            "callSummary"
          ]
        },
        "GeneratePromptRequest": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "driverId",
            "driverName",
            "phoneNumber",
            "triggers",
            "customRules"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\providers\\ditat.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "logging",
        "requests",
        "pandas"
      ],
      "functions": {},
      "classes": {
        "DitatAPIException": {
          "methods": {},
          "inherits": [
            "Exception"
          ],
          "type": "exception",
          "doc": "Custom exception for Ditat API errors."
        },
        "DitatAPI": {
          "methods": {
            "__init__": {
              "signature": "(self, token: str, account_id: str = \"agylogistics\", application_role: str = \"Login to TMS\", base_url: str = \"https://api01.ditat.net/api/tms\")",
              "called_by": [
                "PermissionResponse.__init__",
                "RoleUpdate.__init__",
                "SessionResponse.__init__",
                "AuditLogResponse.__init__",
                "RoleCreate.__init__",
                "RoleResponse.__init__"
              ]
            },
            "_make_request": {
              "signature": "(self, method: str, endpoint: str, use_token: bool = False, **kwargs) -> Dict[str, Any]",
              "called_by": [
                "SamsaraAPI.get_trailers",
                "SamsaraAPI.get_temperatures",
                "SamsaraAPI.get_stats",
                "SamsaraAPI.get_all_sensors",
                "SamsaraAPI.get_stats_in_timeframe",
                "SamsaraAPI.get_locations",
                "DitatAPI.get_dispatch_board"
              ]
            },
            "authenticate": {
              "signature": "(self) -> str",
              "called_by": [
                "DitatAPI.refresh_token",
                "get_trip_data",
                "DitatAPI.get_dispatch_board",
                "get_trailer_and_trips",
                "DitatAPI.get_token"
              ]
            },
            "get_token": {
              "calls": [
                "authenticate"
              ],
              "signature": "(self) -> str"
            },
            "get_dispatch_board": {
              "calls": [
                "_make_request",
                "authenticate"
              ],
              "signature": "(self, filter_config: Optional[Dict[str, Any]] = None, update_counter: int = 0, json_normalize: bool = False,) -> pd.DataFrame"
            },
            "refresh_token": {
              "calls": [
                "authenticate"
              ],
              "signature": "(self) -> str"
            },
            "is_authenticated": {
              "decorators": [
                "property"
              ],
              "signature": "(self) -> bool"
            }
          },
          "doc": "A class to interact with the Ditat API for fetching dispatch and TMS data.",
          "properties": [
            "account_id",
            "application_role",
            "base_url",
            "method",
            "endpoint",
            "use_token",
            "dict",
            "DitatAPIException",
            "str",
            "DitatAPIException",
            "str",
            "filter_config",
            "update_counter",
            "json_normalize",
            "str",
            "bool"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\providers\\samsara.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "logging",
        "uuid",
        "datetime",
        "typing",
        "requests",
        "pandas",
        "helpers.utils"
      ],
      "functions": {},
      "classes": {
        "SamsaraAPIException": {
          "methods": {},
          "inherits": [
            "Exception"
          ],
          "type": "exception",
          "doc": "Custom exception for Samsara API errors."
        },
        "SamsaraAPI": {
          "methods": {
            "__init__": {
              "signature": "(self, token: str, base_url: str = \"https://api.samsara.com\")",
              "called_by": [
                "PermissionResponse.__init__",
                "RoleUpdate.__init__",
                "SessionResponse.__init__",
                "AuditLogResponse.__init__",
                "RoleCreate.__init__",
                "RoleResponse.__init__"
              ]
            },
            "_make_request": {
              "signature": "(self, method: str, endpoint: str, **kwargs) -> Dict[str, Any]",
              "called_by": [
                "SamsaraAPI.get_trailers",
                "SamsaraAPI.get_temperatures",
                "SamsaraAPI.get_stats",
                "SamsaraAPI.get_all_sensors",
                "SamsaraAPI.get_stats_in_timeframe",
                "SamsaraAPI.get_locations",
                "DitatAPI.get_dispatch_board"
              ]
            },
            "get_all_sensors": {
              "calls": [
                "_make_request"
              ],
              "signature": "(self, remove_deactivated: bool = True) -> pd.DataFrame"
            },
            "get_temperatures": {
              "calls": [
                "_make_request"
              ],
              "signature": "(self, sensor_ids: List[int]) -> pd.DataFrame"
            },
            "get_temperatures_batched": "(self, sensor_ids: List[int], batch_size: int = 40) -> pd.DataFrame",
            "get_trailers": {
              "calls": [
                "_make_request"
              ],
              "signature": "(self, tag_ids: Optional[List[int]] = None, after: Optional[Union[str, UUID]] = None, limit: int = 512, json_normalize: bool = False,) -> Tuple[pd.DataFrame, Dict[str, Any]]",
              "called_by": [
                "SamsaraAPI.get_all_trailers"
              ]
            },
            "get_all_trailers": {
              "calls": [
                "get_trailers"
              ],
              "signature": "(self, tag_ids: Optional[List[int]] = None, limit: int = 512, json_normalize: bool = False) -> pd.DataFrame"
            },
            "get_stats": {
              "calls": [
                "_make_request"
              ],
              "signature": "(self, tag_ids: Optional[List[int]] = None, types: Optional[List[str]] = [ \"reeferRunMode\", \"reeferSetPointTemperatureMilliCZone1\", ], after: Optional[Union[str, UUID]] = None, json_normalize: bool = False,) -> Tuple[pd.DataFrame, Dict[str, Any]]",
              "called_by": [
                "SamsaraAPI.get_all_stats"
              ]
            },
            "get_all_stats": {
              "calls": [
                "get_stats"
              ],
              "signature": "(self, tag_ids: Optional[List[int]] = None, types: Optional[List[str]] = [ \"reeferRunMode\", \"reeferSetPointTemperatureMilliCZone1\", ], json_normalize: bool = False,)"
            },
            "get_stats_in_timeframe": {
              "calls": [
                "_make_request"
              ],
              "signature": "(self, start_time: datetime, end_time: datetime, after: Optional[Union[str, UUID]] = None,) -> Tuple[pd.DataFrame, Dict[str, Any]]",
              "called_by": [
                "SamsaraAPI.get_all_stats_in_timeframe"
              ]
            },
            "get_all_stats_in_timeframe": {
              "calls": [
                "get_stats_in_timeframe"
              ],
              "signature": "(self, start_time: datetime, end_time: datetime)"
            },
            "get_locations": {
              "calls": [
                "_make_request"
              ],
              "signature": "(self, json_normalize = True) -> Tuple[pd.DataFrame, Dict[str, Any]]",
              "called_by": [
                "SamsaraAPI.get_all_locations"
              ]
            },
            "get_all_locations": {
              "calls": [
                "get_locations"
              ],
              "signature": "(self, json_normalize = True) -> pd.DataFrame"
            }
          },
          "doc": "A class to interact with the Samsara API for fetching sensor and trailer data.",
          "properties": [
            "token",
            "base_url",
            "method",
            "endpoint",
            "dict",
            "SamsaraAPIException",
            "remove_deactivated",
            "sensor_ids",
            "sensor_ids",
            "batch_size",
            "tag_ids",
            "after",
            "limit",
            "json_normalize",
            "tuple",
            "tag_ids",
            "limit",
            "json_normalize",
            "tag_ids",
            "types",
            "after",
            "json_normalize",
            "tuple",
            "SamsaraAPIException",
            "https",
            "tag_ids",
            "types",
            "json_normalize",
            "https",
            "start_time",
            "end_time",
            "after",
            "tuple",
            "SamsaraAPIException",
            "https",
            "start_time",
            "end_time",
            "https",
            "after",
            "limit",
            "tuple"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\providers\\__init__.py": {
      "language": "python",
      "parsed": false
    },
    "app\\services\\active_load_tracking.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "fastapi",
        "fastapi.responses",
        "helpers",
        "logic.auth.security",
        "models.load_tracking",
        "datetime"
      ],
      "functions": {
        "get_active_load_tracking_by_id": "async (load_id: str)",
        "create_active_load_tracking": "async (record_data: ActiveLoadTrackingCreate)",
        "update_active_load_tracking": "async (load_id: str, record_data: ActiveLoadTrackingUpdate)",
        "delete_active_load_tracking": "async (load_id: str)",
        "upsert_active_load_tracking": "async (record_data: ActiveLoadTrackingUpsert)",
        "update_mute_flag": "async (request_data: MuteFlagUpdateRequest)"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\admin_audit.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "datetime",
        "math",
        "fastapi",
        "sqlmodel",
        "models.user",
        "logic.auth.security",
        "db.database"
      ],
      "functions": {
        "get_audit_logs": {
          "doc": "Get audit logs with filtering",
          "signature": "async (request: Request, user_id: Optional[int] = Query(None), action: Optional[str] = Query(None), resource: Optional[str] = Query(None), start_date: Optional[datetime] = Query(None), end_date: Optional[datetime] = Query(None), page: int = Query(1, ge=1), limit: int = Query(50, ge=1, le=200), current_user: User = Depends(require_audit_view))"
        },
        "get_audit_actions": {
          "doc": "Get all unique audit actions",
          "signature": "async (request: Request, current_user: User = Depends(require_audit_view))"
        },
        "get_audit_resources": {
          "doc": "Get all unique audit resources",
          "signature": "async (request: Request, current_user: User = Depends(require_audit_view))"
        },
        "get_audit_stats": {
          "doc": "Get audit log statistics",
          "signature": "async (request: Request, days: int = Query(7, ge=1, le=90), current_user: User = Depends(require_audit_view))"
        }
      },
      "classes": {
        "AuditLogResponse": {
          "methods": {
            "__init__": {
              "calls": [
                "__init__"
              ],
              "signature": "(self, id: int, user_id: int = None, user_email: str = None, action: str = None, resource: str = None, resource_id: str = None, changes: dict = None, ip_address: str = None, user_agent: str = None, status: str = None, error_message: str = None, timestamp=None)",
              "called_by": [
                "PermissionResponse.__init__",
                "RoleUpdate.__init__",
                "SessionResponse.__init__",
                "AuditLogResponse.__init__",
                "RoleCreate.__init__",
                "RoleResponse.__init__"
              ]
            }
          },
          "inherits": [
            "dict"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\services\\admin_export.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "csv",
        "io",
        "typing",
        "fastapi",
        "fastapi.responses",
        "sqlmodel",
        "models.user",
        "logic.auth.service",
        "logic.auth.security",
        "db.database",
        "models.user"
      ],
      "functions": {
        "export_users": {
          "decorators": [
            "audit_log"
          ],
          "doc": "Export users to CSV or Excel format",
          "calls": [
            "export_users_csv",
            "export_users_xlsx"
          ],
          "signature": "async (request: Request, format: str = Query(\"csv\", regex=\"^(csv|xlsx)$\"), status: Optional[UserStatus] = Query(None), department: Optional[str] = Query(None), current_user: User = Depends(require_user_management))"
        },
        "export_users_csv": {
          "doc": "Export users to CSV format",
          "signature": "(users: List[User]) -> StreamingResponse",
          "called_by": [
            "export_users",
            "export_users_xlsx"
          ]
        },
        "export_users_xlsx": {
          "doc": "Export users to Excel format",
          "calls": [
            "export_users_csv"
          ],
          "signature": "(users: List[User]) -> StreamingResponse",
          "called_by": [
            "export_users"
          ]
        },
        "import_users": {
          "decorators": [
            "audit_log"
          ],
          "doc": "Import users from CSV file",
          "signature": "async (request: Request, file: UploadFile = File(...), current_user: User = Depends(require_user_management))"
        },
        "get_import_template": {
          "doc": "Download CSV template for user import",
          "signature": "async (current_user: User = Depends(require_user_management))"
        }
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\admin_permissions.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "fastapi",
        "sqlmodel",
        "models.user",
        "logic.auth.security",
        "db.database"
      ],
      "functions": {
        "get_permissions": {
          "decorators": [
            "audit_log"
          ],
          "doc": "Get all permissions - returns empty since permissions removed",
          "signature": "async (request: Request, current_user: User = Depends(get_current_active_user))"
        },
        "get_permissions_by_resource": {
          "decorators": [
            "audit_log"
          ],
          "doc": "Get permissions by resource - returns empty since permissions removed",
          "signature": "async (request: Request, resource: str, current_user: User = Depends(get_current_active_user))"
        },
        "get_permission_resources": {
          "decorators": [
            "audit_log"
          ],
          "doc": "Get all unique permission resources - returns empty since permissions removed",
          "signature": "async (request: Request, current_user: User = Depends(get_current_active_user))"
        }
      },
      "classes": {
        "PermissionResponse": {
          "methods": {
            "__init__": {
              "calls": [
                "__init__"
              ],
              "signature": "(self, id: int, name: str, resource: str, action: str, description: str = None)",
              "called_by": [
                "PermissionResponse.__init__",
                "RoleUpdate.__init__",
                "SessionResponse.__init__",
                "AuditLogResponse.__init__",
                "RoleCreate.__init__",
                "RoleResponse.__init__"
              ]
            }
          },
          "inherits": [
            "dict"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\services\\admin_roles.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "fastapi",
        "sqlmodel",
        "models.user",
        "logic.auth.service",
        "logic.auth.security",
        "db.database"
      ],
      "functions": {
        "get_roles": {
          "decorators": [
            "audit_log"
          ],
          "doc": "Get all roles - returns empty since roles removed",
          "signature": "async (request: Request, current_user: User = Depends(get_current_active_user))"
        },
        "get_role": {
          "decorators": [
            "audit_log"
          ],
          "doc": "Get role by ID - always returns not found since roles removed",
          "signature": "async (request: Request, role_id: int, current_user: User = Depends(get_current_active_user))"
        },
        "create_role": {
          "decorators": [
            "audit_log"
          ],
          "doc": "Create new role - disabled since roles removed",
          "signature": "async (request: Request, role_data: dict, current_user: User = Depends(require_role_management))"
        },
        "update_role": {
          "decorators": [
            "audit_log"
          ],
          "doc": "Update role - always returns not found since roles removed",
          "signature": "async (request: Request, role_id: int, role_data: dict, current_user: User = Depends(require_role_management))"
        },
        "delete_role": {
          "decorators": [
            "audit_log"
          ],
          "doc": "Delete role - always returns not found since roles removed",
          "signature": "async (request: Request, role_id: int, current_user: User = Depends(require_role_management))"
        }
      },
      "classes": {
        "RoleCreate": {
          "methods": {
            "__init__": {
              "calls": [
                "__init__"
              ],
              "signature": "(self, name: str, description: str = None, permissions: List[str] = None)",
              "called_by": [
                "PermissionResponse.__init__",
                "RoleUpdate.__init__",
                "SessionResponse.__init__",
                "AuditLogResponse.__init__",
                "RoleCreate.__init__",
                "RoleResponse.__init__"
              ]
            }
          },
          "inherits": [
            "dict"
          ]
        },
        "RoleUpdate": {
          "methods": {
            "__init__": {
              "calls": [
                "__init__"
              ],
              "signature": "(self, name: str = None, description: str = None, permissions: List[str] = None)",
              "called_by": [
                "PermissionResponse.__init__",
                "RoleUpdate.__init__",
                "SessionResponse.__init__",
                "AuditLogResponse.__init__",
                "RoleCreate.__init__",
                "RoleResponse.__init__"
              ]
            }
          },
          "inherits": [
            "dict"
          ]
        },
        "RoleResponse": {
          "methods": {
            "__init__": {
              "calls": [
                "__init__"
              ],
              "signature": "(self, id: int, name: str, description: str = None, permissions: List[str] = None, created_at=None, updated_at=None)",
              "called_by": [
                "PermissionResponse.__init__",
                "RoleUpdate.__init__",
                "SessionResponse.__init__",
                "AuditLogResponse.__init__",
                "RoleCreate.__init__",
                "RoleResponse.__init__"
              ]
            }
          },
          "inherits": [
            "dict"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\services\\admin_sessions.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "math",
        "fastapi",
        "sqlmodel",
        "models.user",
        "logic.auth.service",
        "logic.auth.security",
        "db.database"
      ],
      "functions": {
        "get_sessions": {
          "decorators": [
            "audit_log"
          ],
          "doc": "Get active sessions",
          "signature": "async (request: Request, user_id: Optional[int] = Query(None), page: int = Query(1, ge=1), limit: int = Query(20, ge=1, le=100), current_user: User = Depends(get_current_active_user))"
        },
        "get_session": {
          "decorators": [
            "audit_log"
          ],
          "doc": "Get session by ID",
          "signature": "async (request: Request, session_id: str, current_user: User = Depends(get_current_active_user))",
          "called_by": [
            "Driver.get_all",
            "Driver.get_by_id",
            "Driver.get_by_ids",
            "Driver.get_by_telegram_id",
            "Driver.upsert",
            "Driver.bulk_upsert",
            "Driver.bulk_update_calling_info",
            "DriverTripData.get_all",
            "DriverTripData.get_by_driver",
            "DriverTripData.get_latest_by_driver",
            "DriverTripData.get_by_trip",
            "ActiveLoadTracking.get_all",
            "ActiveLoadTracking.get_by_trip",
            "ViolationAlertDriver.get_all",
            "ViolationAlertDriver.get_by_trip_id",
            "DriverMapping.get_with_filters",
            "DriverMapping.get_by_driverid",
            "DriverMapping.get_by_driverkey",
            "DriverMapping.create",
            "DriverMapping.update",
            "DriverMapping.delete",
            "DriverReport.get_all",
            "DriverReport.get_by_trip_id",
            "DriverMorningReport.get_all",
            "DriverMorningReport.get_by_driver_id",
            "DriverTriggersData.get_trip_by_driver_id",
            "ActiveLoadTracking.get_all",
            "ActiveLoadTracking.get_by_id",
            "ActiveLoadTracking.get_by_status",
            "ActiveLoadTracking.get_by_created_at",
            "ActiveLoadTracking.create",
            "ActiveLoadTracking.update",
            "ActiveLoadTracking.delete",
            "ActiveLoadTracking.get_by_mute_flag",
            "ActiveLoadTracking.update_mute_flag_by_trip_id",
            "ActiveLoadTracking.upsert",
            "ViolationAlert.get_all",
            "ViolationAlert.get_by_id",
            "ViolationAlert.get_by_created_at",
            "ViolationAlert.create",
            "ViolationAlert.update",
            "ViolationAlert.delete",
            "ViolationAlert.upsert",
            "DispatchedTrip.get_all",
            "DispatchedTrip.get_by_id",
            "DispatchedTrip.create",
            "DispatchedTrip.update",
            "DispatchedTrip.delete",
            "DispatchedTrip.delete_by_trip_key",
            "DispatchedTrip.upsert",
            "TempSensorMapping.get_all",
            "TempSensorMapping.get_by_sensor_name",
            "TempSensorMapping.get_by_sensor_id",
            "TempSensorMapping.create",
            "TempSensorMapping.update",
            "TempSensorMapping.upsert",
            "TempSensorMapping.delete",
            "TrailerUnitMapping.get_all",
            "TrailerUnitMapping.get_by_trailer_unit",
            "TrailerUnitMapping.get_by_trailer_id",
            "TrailerUnitMapping.create",
            "TrailerUnitMapping.update",
            "TrailerUnitMapping.upsert",
            "TrailerUnitMapping.delete",
            "Trip.get_all",
            "Trip.get_by_trip_id",
            "Trip.get_by_driver_id",
            "Trip.create",
            "Trip.update",
            "Trip.upsert",
            "Trip.delete",
            "Trip.truncate_table",
            "TruckMapping.get_all",
            "TruckMapping.get_by_truck_unit",
            "TruckMapping.get_by_truck_id",
            "TruckMapping.get_by_truck_key",
            "TruckMapping.create",
            "TruckMapping.update",
            "TruckMapping.upsert",
            "TruckMapping.delete"
          ]
        },
        "terminate_session": {
          "decorators": [
            "audit_log"
          ],
          "doc": "Terminate session",
          "signature": "async (request: Request, session_id: str, current_user: User = Depends(get_current_active_user))"
        },
        "terminate_user_sessions": {
          "decorators": [
            "audit_log"
          ],
          "doc": "Terminate all user sessions",
          "signature": "async (request: Request, user_id: int, current_user: User = Depends(get_current_active_user))"
        },
        "cleanup_expired_sessions": {
          "decorators": [
            "audit_log"
          ],
          "doc": "Cleanup expired sessions",
          "calls": [
            "cleanup_expired_sessions"
          ],
          "signature": "async (request: Request, current_user: User = Depends(get_current_active_user))",
          "called_by": [
            "cleanup_expired_sessions",
            "cleanup_expired_sessions"
          ]
        }
      },
      "classes": {
        "SessionResponse": {
          "methods": {
            "__init__": {
              "calls": [
                "__init__"
              ],
              "signature": "(self, id: str, user_id: int, user_email: str, ip_address: str = None, user_agent: str = None, last_activity=None, expires_at=None, is_active: bool = True)",
              "called_by": [
                "PermissionResponse.__init__",
                "RoleUpdate.__init__",
                "SessionResponse.__init__",
                "AuditLogResponse.__init__",
                "RoleCreate.__init__",
                "RoleResponse.__init__"
              ]
            }
          },
          "inherits": [
            "dict"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\services\\admin_users.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "datetime",
        "math",
        "fastapi",
        "sqlmodel",
        "config",
        "models.user",
        "logic.auth.service",
        "logic.auth.security",
        "db.database",
        "models.user",
        "logic.auth.service",
        "logic.auth.service",
        "logic.auth.service",
        "logic.auth.service",
        "logic.auth.service",
        "logic.auth.service",
        "secrets",
        "string",
        "logic.auth.service",
        "logic.auth.service",
        "models.user",
        "models.user",
        "models.user",
        "logic.auth.service",
        "models.user",
        "logic.auth.service",
        "logic.auth.security",
        "logic.auth.service",
        "logic.auth.service",
        "logic.auth.service",
        "logic.auth.service"
      ],
      "functions": {
        "build_user_response": {
          "doc": "Build user response with roles and permissions - FAST VERSION",
          "signature": "(user: User) -> UserResponse",
          "called_by": [
            "get_user",
            "update_user",
            "login",
            "create_user",
            "get_current_user_info"
          ]
        },
        "get_users": {
          "doc": "Get all users with filtering and pagination",
          "signature": "async (request: Request, page: int = Query(1, ge=1), limit: int = Query(20, ge=1, le=100), search: Optional[str] = Query(None), status: Optional[UserStatus] = Query(None), role_id: Optional[int] = Query(None), department: Optional[str] = Query(None), current_user: User = Depends(require_user_view))"
        },
        "get_user_stats": {
          "doc": "Get user statistics",
          "signature": "async (request: Request, current_user: User = Depends(require_user_view))"
        },
        "get_user": {
          "doc": "Get user by ID - FAST VERSION",
          "calls": [
            "build_user_response"
          ],
          "signature": "async (request: Request, user_id: int, current_user: User = Depends(require_user_view))"
        },
        "update_user": {
          "doc": "Update user - FAST VERSION",
          "calls": [
            "build_user_response"
          ],
          "signature": "async (request: Request, user_id: int, user_data: dict, # Accept dict instead of UserUpdate to handle camelCase current_user: User = Depends(require_user_management))"
        },
        "delete_user": {
          "doc": "Delete user",
          "calls": [
            "delete_user"
          ],
          "signature": "async (request: Request, user_id: int, current_user: User = Depends(require_user_management))",
          "called_by": [
            "delete_user"
          ]
        },
        "suspend_user": {
          "doc": "Suspend user - FAST VERSION",
          "signature": "async (request: Request, user_id: int, reason: str = Query(..., description=\"Reason for suspension\"), current_user: User = Depends(require_user_management))"
        },
        "activate_user": {
          "doc": "Activate user - FAST VERSION",
          "signature": "async (request: Request, user_id: int, current_user: User = Depends(require_user_management))"
        },
        "approve_user": {
          "doc": "Approve pending user - FAST VERSION",
          "signature": "async (request: Request, user_id: int, current_user: User = Depends(require_user_management))"
        },
        "reject_user": {
          "doc": "Reject pending user (sets status to suspended) - FAST VERSION",
          "signature": "async (request: Request, user_id: int, reason: str = Query(None, description=\"Reason for rejection\"), current_user: User = Depends(require_user_management))"
        },
        "admin_reset_password": {
          "doc": "Admin reset user password - WORKING VERSION",
          "signature": "async (request: Request, user_id: int, current_user: User = Depends(require_user_management))"
        },
        "get_user_sessions": {
          "doc": "Get sessions for a specific user (active by default, or all if include_inactive=true)",
          "signature": "async (request: Request, user_id: int, include_inactive: bool = Query(False, description=\"Include terminated sessions for history\"), current_user: User = Depends(require_user_view))"
        },
        "get_all_active_sessions": {
          "doc": "Get all sessions across all users (active by default, or all if include_inactive=true)",
          "signature": "async (request: Request, page: int = Query(1, ge=1), limit: int = Query(50, ge=1, le=200), include_inactive: bool = Query(False, description=\"Include terminated sessions for history\"), current_user: User = Depends(require_user_view))"
        },
        "force_logout_user": {
          "doc": "Force logout user (terminate all sessions) with token revocation",
          "signature": "async (request: Request, user_id: int, current_user: User = Depends(require_user_management))"
        },
        "terminate_single_session": {
          "doc": "Terminate a single session by session ID with token revocation",
          "signature": "async (request: Request, session_id: str, current_user: User = Depends(require_user_management))"
        },
        "revoke_current_token": {
          "doc": "Revoke the current token being used (for testing)",
          "signature": "async (request: Request, token: str = Depends(oauth2_scheme), current_user: User = Depends(require_user_management))"
        },
        "cleanup_expired_sessions": {
          "doc": "Cleanup expired sessions (admin endpoint)",
          "calls": [
            "cleanup_expired_sessions"
          ],
          "signature": "async (request: Request, current_user: User = Depends(require_user_management))",
          "called_by": [
            "cleanup_expired_sessions",
            "cleanup_expired_sessions"
          ]
        },
        "change_password": {
          "doc": "User change their own password",
          "signature": "async (request: Request, current_password: str = Query(..., description=\"Current password\"), new_password: str = Query(..., description=\"New password\"), current_user: User = Depends(get_current_active_user))"
        },
        "bulk_update_users": {
          "decorators": [
            "rate_limit"
          ],
          "doc": "Bulk update users",
          "signature": "async (request: Request, user_ids: List[int], updates: dict, current_user: User = Depends(require_user_management))"
        },
        "bulk_delete_users": {
          "decorators": [
            "rate_limit"
          ],
          "doc": "Bulk delete users",
          "signature": "async (request: Request, user_ids: List[int], current_user: User = Depends(require_user_management))"
        }
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\auth.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "datetime",
        "typing",
        "fastapi.security",
        "fastapi",
        "config",
        "models.user",
        "logic.auth.service",
        "logic.auth.security",
        "models.user",
        "sqlmodel",
        "db.database",
        "uuid",
        "models.user",
        "sqlmodel",
        "db.database",
        "models.user",
        "sqlmodel",
        "db.database",
        "logic.auth.security",
        "logic.auth.service"
      ],
      "functions": {
        "build_user_response": {
          "doc": "Build user response for frontend",
          "signature": "(user: User) -> dict",
          "called_by": [
            "get_user",
            "update_user",
            "login",
            "create_user",
            "get_current_user_info"
          ]
        },
        "login": {
          "doc": "User authentication endpoint",
          "calls": [
            "build_user_response"
          ],
          "signature": "async (request: Request, form_data: OAuth2PasswordRequestForm = Depends())"
        },
        "create_user": {
          "doc": "Create new user (admin or registration)",
          "calls": [
            "build_user_response",
            "create_user"
          ],
          "signature": "async (request: Request, user_data: UserCreate, current_user: User = Depends(get_current_active_user))",
          "called_by": [
            "create_user",
            "create_user"
          ]
        },
        "register_user": {
          "doc": "User registration endpoint with domain validation and email verification",
          "signature": "async (request: Request, user_data: UserCreate)"
        },
        "verify_otp": {
          "doc": "Verify OTP code and create user account",
          "signature": "async (request: Request, verification_data: dict # expects {\"email\": \"user@agylogistics.com\", \"otp_code\": \"123456\"})"
        },
        "get_verification_token": {
          "doc": "DEBUG: Get verification token for testing - REMOVE IN PRODUCTION",
          "signature": "async (user_id: int)"
        },
        "refresh_token": {
          "doc": "Refresh access token using refresh token and update session activity",
          "signature": "async (request: Request, refresh_token: str)"
        },
        "logout": {
          "doc": "Logout and invalidate session",
          "signature": "async (request: Request, current_user: User = Depends(get_current_active_user), token: str = Depends(oauth2_scheme))"
        },
        "forgot_password": {
          "doc": "Initiate password reset process",
          "signature": "async (request: Request, email: str)"
        },
        "reset_password": {
          "doc": "Reset password with token",
          "signature": "async (request: Request, token: str, new_password: str)"
        },
        "get_current_user_info": {
          "doc": "Get current user information",
          "calls": [
            "build_user_response"
          ],
          "signature": "async (current_user: User = Depends(get_current_active_user))"
        },
        "check_token_status": {
          "doc": "Check current token status - FOR FRONTEND PERIODIC VALIDATION",
          "signature": "async (token: str = Depends(oauth2_scheme))"
        }
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\dispatched_trips.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "fastapi",
        "fastapi.responses",
        "helpers",
        "logic.auth.security",
        "models.load_tracking"
      ],
      "functions": {
        "get_dispatched_trip_by_id": "async (trip_id: str)",
        "create_dispatched_trip": "async (record_data: DispatchedTripCreate)",
        "update_dispatched_trip": "async (trip_id: str, record_data: DispatchedTripUpdate)",
        "delete_dispatched_trip": "async (trip_id: str)",
        "delete_dispatched_trip_by_trip_key": "async (trip_key: int)",
        "upsert_dispatched_trip": "async (record_data: DispatchedTripUpsert)"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\drivers.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "fastapi",
        "fastapi.responses",
        "helpers",
        "logic.auth.security",
        "models.drivers"
      ],
      "functions": {
        "get_all_drivers_data_endpoint": "async (limit: int = 5000)",
        "get_driver_data_endpoint": "async (driver_id: str)",
        "get_driver_by_telegram_id": "async (telegram_id: str)",
        "upsert_driver": "async (driver_data: DriverCallUpdate)",
        "bulk_upsert_drivers": "async (drivers_data: List[DriverCallUpdate])",
        "configure_driver_call_settings": "async (updates: List[DriverCallUpdate])"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\driver_data.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "fastapi",
        "models.driver_data",
        "models.vapi"
      ],
      "functions": {
        "get_all_trips": "()",
        "get_by_trip": {
          "calls": [
            "get_by_trip"
          ],
          "signature": "(trip_id)",
          "called_by": [
            "get_driver_summary",
            "get_trip_data_for_violations",
            "get_by_trip",
            "get_driver_combined"
          ]
        },
        "get_all_active_loads": "()",
        "get_driver_combined": {
          "calls": [
            "get_by_trip"
          ],
          "signature": "(trip_id: str)"
        },
        "make_driver_violation_call": "async (request: BatchCallRequest)",
        "generate_prompt": "async (request: GeneratePromptRequest)"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\driver_mapping.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "fastapi",
        "fastapi.responses",
        "helpers",
        "logic.auth.security",
        "models.driver_mapping"
      ],
      "functions": {
        "get_driver_mappings": "async (driverid: Optional[str] = Query(None, description=\"Filter by driver ID\"), driverkey: Optional[str] = Query(None, description=\"Filter by driver key\"), driverfullname: Optional[str] = Query(None, description=\"Filter by driver full name (case-insensitive partial match)\"), limit: int = Query(100, ge=1, le=1000, description=\"Number of records to return (default: 100, max: 1000)\"), offset: int = Query(0, ge=0, description=\"Pagination offset (default: 0)\"), sort: Optional[str] = Query(None, description=\"Sort field (e.g., 'driverid', '-driverid' for DESC)\"))",
        "get_driver_mapping_by_id": "async (driverid: str)",
        "create_driver_mapping": "async (mapping_data: DriverMappingCreate)",
        "update_driver_mapping": "async (driverid: str, mapping_data: DriverMappingUpdate)",
        "delete_driver_mapping": "async (driverid: str)"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\driver_prompt_service.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "fastapi",
        "sqlmodel",
        "datetime",
        "db",
        "models.driver_model_prompt",
        "typing",
        "pydantic",
        "uuid"
      ],
      "functions": {
        "get_all_prompts": "async ()",
        "get_prompt_by_name": "async (prompt_name: str)",
        "update_prompt": "async (request: UpdateDriverPromptRequest)"
      },
      "classes": {
        "UpdateDriverPromptRequest": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "prompt_name",
            "condition_true_prompt",
            "condition_false_prompt"
          ]
        },
        "SystemPromptPayload": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "prompt_name"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\services\\driver_triggers.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "fastapi",
        "models.driver_triggers",
        "pydantic",
        "typing"
      ],
      "functions": {
        "get_trip_driverId": "(driver_id: str)",
        "make_driver_vapi_call": "async (request: DriverTriggerRequest)"
      },
      "classes": {
        "Driver": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "driverId",
            "name",
            "phone"
          ]
        },
        "DriverReminders": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "id",
            "message"
          ]
        },
        "DriverTriggerRequest": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "driver",
            "selectedReminders",
            "selectedViolations"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\services\\email_service.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "smtplib",
        "email.mime.text",
        "email.mime.multipart",
        "typing",
        "config"
      ],
      "functions": {},
      "classes": {
        "EmailService": {
          "methods": {
            "send_otp_email": {
              "decorators": [
                "staticmethod"
              ],
              "doc": "Send OTP verification email",
              "signature": "(to_email: str, otp_code: str, full_name: str) -> bool"
            },
            "send_welcome_email": {
              "decorators": [
                "staticmethod"
              ],
              "doc": "Send welcome email after user approval",
              "signature": "(to_email: str, full_name: str) -> bool"
            }
          },
          "properties": [
            "Important"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\services\\ingest.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "datetime",
        "fastapi",
        "fastapi.responses",
        "helpers",
        "logic.auth.security",
        "helpers.time_utils",
        "helpers.utils",
        "logic.ingest"
      ],
      "functions": {
        "ingest_ditat": "async ()",
        "ingest_samsara_temp": {
          "calls": [
            "detailed_location",
            "detailed_trailer_stats",
            "trailer_stats",
            "trailer_temp"
          ],
          "signature": "async ()"
        },
        "backfill_samsara_detailed_stats": {
          "calls": [
            "_get_key",
            "_ingest"
          ],
          "signature": "async (start_ms: int, end_ms: int, unit: TimeUnit = TimeUnit.DAYS, granularity: int = 1)"
        }
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\page_access_token_service.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "fastapi",
        "sqlmodel",
        "typing",
        "uuid",
        "logic.auth.security",
        "models.page_access_token_model",
        "db.database",
        "pydantic"
      ],
      "functions": {
        "get_all_tokens": "async ()",
        "create_or_update_token": {
          "calls": [
            "create_or_update_page_access_token"
          ],
          "signature": "async (payload: PageAccessTokenRequest)"
        },
        "get_token": {
          "calls": [
            "get_page_access_token"
          ],
          "signature": "async (token_id: UUID)"
        },
        "delete_token": {
          "calls": [
            "nullify_token_only"
          ],
          "signature": "async (token_id: UUID)"
        },
        "verify_token": "async (page_access_token: str)"
      },
      "classes": {
        "PageAccessTokenRequest": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "page_name",
            "page_url",
            "filter"
          ]
        },
        "PageAccessTokenService": {
          "methods": {
            "create_or_update_page_access_token": {
              "decorators": [
                "staticmethod"
              ],
              "signature": "(page_name: str, page_url: str, db: Session, filter: Optional[str] = None) -> PageAccessTokens",
              "called_by": [
                "create_or_update_token"
              ]
            },
            "get_page_access_token": {
              "decorators": [
                "staticmethod"
              ],
              "signature": "(token_id: UUID, db: Session) -> Optional[PageAccessTokens]",
              "called_by": [
                "get_token"
              ]
            },
            "nullify_token_only": {
              "decorators": [
                "staticmethod"
              ],
              "signature": "(token_id: UUID, db: Session) -> bool",
              "called_by": [
                "delete_token"
              ]
            }
          }
        }
      },
      "call_graph": {}
    },
    "app\\services\\pcmiler.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "datetime",
        "typing",
        "fastapi",
        "httpx",
        "helpers",
        "logic.auth.security",
        "models.pcmiler",
        "config"
      ],
      "functions": {
        "get_eta": "async (request: ETARequest)"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\reports.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "fastapi",
        "helpers",
        "logic.auth.security",
        "models.driver_reports",
        "models.drivers"
      ],
      "functions": {
        "get_all_driver_reports": "async ()",
        "get_driver_morning_reports": "async ()"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\slack.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "time",
        "hmac",
        "hashlib",
        "fastapi",
        "helpers",
        "config",
        "logic.alerts"
      ],
      "functions": {
        "verify_slack_request": {
          "signature": "async (request: Request)",
          "called_by": [
            "slack_interactive_endpoint"
          ]
        },
        "slack_interactive_endpoint": {
          "calls": [
            "verify_slack_request"
          ],
          "signature": "async (request: Request, bt: BackgroundTasks = BackgroundTasks())"
        }
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\temp_sensor_mapping.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "fastapi",
        "fastapi.responses",
        "helpers",
        "logic.auth.security",
        "models.temp_sensor_mapping"
      ],
      "functions": {
        "get_all_temp_sensor_mappings": "async (limit: int = 5000)",
        "get_temp_sensor_mapping_by_name": "async (sensor_name: str)",
        "get_temp_sensor_mapping_by_id": "async (sensor_id: int)",
        "upsert_temp_sensor_mapping": "async (mapping_data: TempSensorMappingCreate)",
        "create_temp_sensor_mapping": "async (mapping_data: TempSensorMappingCreate)",
        "update_temp_sensor_mapping": "async (sensor_name: str, mapping_data: TempSensorMappingUpdate)",
        "delete_temp_sensor_mapping": "async (sensor_name: str)"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\test_service.py": {
      "language": "python",
      "parsed": true,
      "purpose": "Test file",
      "imports": [
        "fastapi",
        "models",
        "fastapi"
      ],
      "functions": {
        "get_books": "()",
        "get_book_id": "(book_id:int)"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\trailer_unit_mapping.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "fastapi",
        "fastapi.responses",
        "helpers",
        "logic.auth.security",
        "models.trailer_unit_mapping"
      ],
      "functions": {
        "get_all_trailer_unit_mappings": "async (limit: int = 5000)",
        "get_trailer_unit_mapping_by_unit": "async (trailer_unit: str)",
        "get_trailer_unit_mapping_by_id": "async (trailer_id: int)",
        "upsert_trailer_unit_mapping": "async (mapping_data: TrailerUnitMappingCreate)",
        "create_trailer_unit_mapping": "async (mapping_data: TrailerUnitMappingCreate)",
        "update_trailer_unit_mapping": "async (trailer_unit: str, mapping_data: TrailerUnitMappingUpdate)",
        "delete_trailer_unit_mapping": "async (trailer_unit: str)"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\trips.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "fastapi",
        "fastapi.responses",
        "pydantic",
        "helpers.time_utils",
        "logic.trips",
        "logic.auth.security",
        "logic.trips",
        "models.trips",
        "helpers",
        "datetime"
      ],
      "functions": {
        "trailer_trips": "async ()",
        "trip_data": "async (trip_id: str, trailer_id: str)",
        "get_latest_alerts": "async (value: int = Query(1, gt=0, description=\"Numeric value for time unit\"), unit: BQTimeUnit = Query(BQTimeUnit.HOUR, description=\"Unit of time (minutes, hours, days, ...)\"), bt: BackgroundTasks = BackgroundTasks(),)",
        "get_all_trips": "async (limit: int = 5000)",
        "get_trip_by_id": "async (trip_id: str)",
        "get_trips_by_driver": "async (driver_id: str)",
        "upsert_trip": "async (trip_data: TripCreate)",
        "update_customer_group": "async (data: CustomerGroupUpdate)",
        "truncate_trips_table": "async ()"
      },
      "classes": {
        "CustomerGroupUpdate": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "tripId",
            "customerGroup"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\services\\truck_mapping.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "fastapi",
        "fastapi.responses",
        "helpers",
        "logic.auth.security",
        "models.truck_mapping"
      ],
      "functions": {
        "get_all_truck_mappings": "async (limit: int = 5000)",
        "get_truck_mapping_by_unit": "async (truck_unit: str)",
        "get_truck_mapping_by_id": "async (truck_id: int)",
        "get_truck_mapping_by_key": "async (truck_key: str)",
        "upsert_truck_mapping": "async (mapping_data: TruckMappingCreate)",
        "create_truck_mapping": "async (mapping_data: TruckMappingCreate)",
        "update_truck_mapping": "async (truck_unit: str, mapping_data: TruckMappingUpdate)",
        "delete_truck_mapping": "async (truck_unit: str)"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\users.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "datetime",
        "fastapi",
        "sqlmodel",
        "models.user",
        "logic.auth.security",
        "logic.auth.service",
        "db.database"
      ],
      "functions": {
        "get_user": {
          "doc": "Get user details including role and allowed pages",
          "signature": "async (request: Request, user_id: int, current_user: User = Depends(get_current_active_user))"
        },
        "update_user": {
          "doc": "Update user information (name, email, phone, address)",
          "signature": "async (request: Request, user_id: int, user_data: UserUpdate, current_user: User = Depends(get_current_active_user))"
        },
        "update_user_role": {
          "doc": "Update user role (admin, super_admin, user)",
          "signature": "async (request: Request, user_id: int, role_data: dict, # expects {\"role\": \"admin\"} or {\"role\": \"super_admin\"} or {\"role\": \"user\"} current_user: User = Depends(get_current_active_user))"
        },
        "update_user_permissions": {
          "doc": "Update user page permissions",
          "signature": "async (request: Request, user_id: int, permissions_data: dict, # expects {\"pages\": [\"dashboard\", \"drivers\", \"admin_panel\"]} current_user: User = Depends(get_current_active_user))"
        },
        "approve_user": {
          "doc": "Approve a pending user",
          "signature": "async (request: Request, user_id: int, current_user: User = Depends(get_current_active_user))"
        },
        "delete_user": {
          "doc": "Delete a user completely",
          "signature": "async (request: Request, user_id: int, current_user: User = Depends(get_current_active_user))",
          "called_by": [
            "delete_user"
          ]
        }
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\vapi.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "fastapi",
        "fastapi.responses",
        "helpers",
        "logic.auth.security",
        "models.drivers",
        "models.driver_reports",
        "models.vapi",
        "utils.vapi_client",
        "sqlmodel",
        "sqlmodel"
      ],
      "functions": {
        "make_vapi_call": "async (driver_id: str, body: Optional[VAPIData] = None)",
        "make_vapi_calls_to_multiple_drivers": "async (request: VAPICallRequest)",
        "update_driver_call_insights": "async (update_data: DriverCallInsightsUpdate)"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\violation_alerts.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "fastapi",
        "fastapi.responses",
        "helpers",
        "logic.auth.security",
        "models.load_tracking"
      ],
      "functions": {
        "get_violation_alert_by_id": "async (alert_id: int)",
        "create_violation_alert": "async (record_data: ViolationAlertCreate)",
        "update_violation_alert": "async (alert_id: int, record_data: ViolationAlertUpdate)",
        "delete_violation_alert": "async (alert_id: int)",
        "upsert_violation_alert": "async (record_data: ViolationAlertUpsert)"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\weather.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "fastapi",
        "typing",
        "pydantic",
        "logic.weather",
        "logic.auth.security",
        "models.user"
      ],
      "functions": {
        "get_current_weather": {
          "calls": [
            "get_current_weather"
          ],
          "signature": "async (location: str = Query(..., description=\"Location (city name, zip code, coordinates, IP address)\"), aqi: bool = Query(False, description=\"Include air quality data\"), current_user: User = Depends(get_current_active_user))",
          "called_by": [
            "get_current_weather"
          ]
        }
      },
      "classes": {
        "WeatherResponse": {
          "methods": {},
          "inherits": [
            "BaseModel"
          ],
          "properties": [
            "location",
            "current",
            "error"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\services\\webhook.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "fastapi",
        "fastapi.responses",
        "models.alert_filter",
        "logic.auth.security",
        "helpers.agy_utils",
        "logic.alerts"
      ],
      "functions": {
        "send_muted_entities_to_slack": "async (channel: str)",
        "mute_entity_alert": "async (mute_type: MuteEnum = MuteEnum.MUTE, entity_id: str = Depends(validate_entity_id_in_path), bt: BackgroundTasks = BackgroundTasks(),)"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\__init__.py": {
      "language": "python",
      "parsed": false
    },
    "app\\utils\\call_insights.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "re",
        "typing"
      ],
      "functions": {
        "extract_insights": {
          "calls": [
            "get_match"
          ],
          "signature": "(transcript: str) -> Dict[str, Any]"
        }
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\utils\\vapi_client.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "httpx",
        "typing",
        "config",
        "helpers"
      ],
      "functions": {},
      "classes": {
        "VAPIClient": {
          "methods": {
            "__init__": {
              "signature": "(self)",
              "called_by": [
                "PermissionResponse.__init__",
                "RoleUpdate.__init__",
                "SessionResponse.__init__",
                "AuditLogResponse.__init__",
                "RoleCreate.__init__",
                "RoleResponse.__init__"
              ]
            },
            "create_vapi_call": "async (self, driver_data: Union[Dict[str, Any], List[Dict[str, Any]]]) -> Dict[str, Any]",
            "get_call_status": "async (self, call_id: str) -> Dict[str, Any]"
          },
          "properties": [
            "driver_data",
            "call_id"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\utils\\weather_api.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "json",
        "dataclasses",
        "datetime",
        "pytz",
        "requests",
        "pandas",
        "pandas_gbq",
        "fastapi",
        "config",
        "helpers.utils"
      ],
      "functions": {
        "make_weather_info": {
          "signature": "(wd: WeatherData)",
          "called_by": [
            "get_weather_df"
          ]
        },
        "cache_weather_bq": {
          "signature": "(wds: list[WeatherData])",
          "called_by": [
            "get_weather_df"
          ]
        },
        "get_weather": {
          "doc": "Fetch current weather conditions for a given lat/lon.",
          "signature": "(lat: float, lon: float, aqi: bool = False)",
          "called_by": [
            "get_weather_df"
          ]
        },
        "get_weather_df": {
          "calls": [
            "cache_weather_bq",
            "get_weather",
            "get_weather_data",
            "make_weather_info"
          ],
          "signature": "(lat_lons: list[tuple[float, float]], bt: BackgroundTasks | None = None, keep_raw_columns_in_df: bool = False)"
        }
      },
      "classes": {
        "WeatherData": {
          "methods": {},
          "decorators": [
            "dataclass"
          ],
          "properties": [
            "latitude",
            "longitude",
            "location",
            "region",
            "temperature",
            "description",
            "wind_mph",
            "timestamp",
            "raw_data"
          ]
        }
      },
      "call_graph": {}
    },
    "app\\services\\alerts\\filters.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "fastapi",
        "logic.alerts",
        "logic.auth.security",
        "helpers.agy_utils",
        "models.alert_filter"
      ],
      "functions": {
        "get_alert_filters": "async (only_muted: bool = False)",
        "create_alert_filter": "async (alert_filter: AlertFilterCreate)",
        "get_alert_filter_with_entity_id": "async (entity_id: str = Depends(validate_entity_id_in_path))",
        "update_alert_filter_with_entity_id": "async (entity_id: str = Depends(validate_entity_id_in_path), alert_filter: AlertFilterUpdate = Body(...),)",
        "delete_alert_filter_with_entity_id": "async (entity_id: str = Depends(validate_entity_id_in_path))",
        "get_alert_filter_with_id": "async (filter_id: int)",
        "update_alert_filter_with_id": "async (filter_id: int, alert_filter: AlertFilterUpdate = Body(...),)",
        "delete_alert_filter_with_id": "async (filter_id: int)"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\alerts\\slack.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "fastapi",
        "fastapi.responses",
        "logic.alerts",
        "logic.auth.security"
      ],
      "functions": {
        "slack_temp_alerts": "async (bt: BackgroundTasks = BackgroundTasks())"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\services\\alerts\\__init__.py": {
      "language": "python",
      "parsed": false
    },
    "app\\logic\\alerts\\filters.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "collections",
        "datetime",
        "pandas",
        "sqlmodel",
        "helpers",
        "db.database",
        "helpers.agy_utils",
        "models.alert_filter"
      ],
      "functions": {
        "filter_df_by_alert_filters": {
          "calls": [
            "get_excluded_alert_filters"
          ],
          "signature": "(df: pd.DataFrame, filters: list[AlertFilter] | None = None, idtype_column_map: dict[IdType, str] = default_idtype_column_map,) -> pd.DataFrame"
        },
        "get_excluded_alert_filters": {
          "signature": "()",
          "called_by": [
            "filter_df_by_alert_filters"
          ]
        },
        "get_all_alert_filters": "()",
        "get_alert_filter_by_id": "(filter_id: int)",
        "get_alert_filter_by_entity_id": {
          "signature": "(entity_id: str)",
          "called_by": [
            "toggle_entity_alert"
          ]
        },
        "create_alert_filter_db": {
          "signature": "(alert_filter: AlertFilterCreate)",
          "called_by": [
            "toggle_entity_alert"
          ]
        },
        "_update_alert_filter_generic": {
          "signature": "(column, value, alert_filter: AlertFilterUpdate)",
          "called_by": [
            "update_alert_filter_by_id",
            "update_alert_filter_by_entity_id"
          ]
        },
        "update_alert_filter_by_id": {
          "calls": [
            "_update_alert_filter_generic"
          ],
          "signature": "(filter_id: int, alert_filter: AlertFilterUpdate)"
        },
        "update_alert_filter_by_entity_id": {
          "calls": [
            "_update_alert_filter_generic"
          ],
          "signature": "(entity_id: str, alert_filter: AlertFilterUpdate)",
          "called_by": [
            "toggle_entity_alert"
          ]
        },
        "_delete_alert_filter_generic": {
          "signature": "(column, value)",
          "called_by": [
            "delete_alert_filter_by_id",
            "delete_alert_filter_by_entity_id"
          ]
        },
        "delete_alert_filter_by_id": {
          "calls": [
            "_delete_alert_filter_generic"
          ],
          "signature": "(filter_id: int)"
        },
        "delete_alert_filter_by_entity_id": {
          "calls": [
            "_delete_alert_filter_generic"
          ],
          "signature": "(entity_id: str)"
        },
        "toggle_entity_alert": {
          "calls": [
            "create_alert_filter_db",
            "get_alert_filter_by_entity_id",
            "update_alert_filter_by_entity_id"
          ],
          "signature": "(entity_id: str, mute: bool = True)"
        }
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\logic\\alerts\\slack.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "enum",
        "datetime",
        "typing",
        "collections",
        "cachetools",
        "fastapi",
        "pytz",
        "pandas",
        "pandas_gbq",
        "config",
        "models.slack",
        "models.alert_filter",
        "helpers.agy_utils",
        "helpers.time_utils",
        "logic.alerts.filters",
        "utils.weather_api"
      ],
      "functions": {
        "process_message_generic": "(message: str)",
        "send_slack_temp_alerts": {
          "calls": [
            "create_mute_actions",
            "get_generated_at",
            "get_muted_list_section"
          ],
          "signature": "(bt: BackgroundTasks | None = None)"
        },
        "trips_within_24hours": {
          "decorators": [
            "cached"
          ],
          "signature": "() -> list[str]",
          "called_by": [
            "send_muted_entities"
          ]
        },
        "send_muted_entities": {
          "doc": "Send muted entities across multiple messages if needed.",
          "calls": [
            "get_generated_at",
            "get_unmute_section",
            "send_empty_payload",
            "trips_within_24hours"
          ],
          "signature": "(channel: str, user_id: str = None)"
        },
        "toggle_entity_alert_and_notify": "(entity_id: str, mute_type: MuteEnum, channel: str, user_id: str = None)",
        "get_action_button": {
          "calls": [
            "to_id",
            "to_value"
          ],
          "signature": "(entity_id: str, mute_type: MuteEnum, channel: str, btn_style=ButtonStyle.DANGER)",
          "called_by": [
            "create_mute_actions",
            "get_unmute_section"
          ]
        },
        "create_mute_actions": {
          "doc": "Create action buttons for muting/unmuting alerts by trip or trailer",
          "calls": [
            "get_action_button"
          ],
          "signature": "(entity_ids: list[str], channel: str)",
          "called_by": [
            "send_slack_temp_alerts"
          ]
        },
        "get_unmute_section": {
          "calls": [
            "get_action_button"
          ],
          "signature": "(entity_id: str, channel: str)",
          "called_by": [
            "send_muted_entities"
          ]
        },
        "get_muted_list_section": {
          "calls": [
            "to_id",
            "to_value"
          ],
          "signature": "(channel: str)",
          "called_by": [
            "send_slack_temp_alerts"
          ]
        },
        "get_generated_at": {
          "signature": "()",
          "called_by": [
            "send_slack_temp_alerts",
            "send_muted_entities"
          ]
        },
        "send_empty_payload": {
          "signature": "(header: str, desc: str, footer: str, channel: str)",
          "called_by": [
            "send_muted_entities"
          ]
        }
      },
      "classes": {
        "ActionValue": {
          "methods": {
            "from_value": {
              "decorators": [
                "classmethod"
              ],
              "signature": "(cls, value)"
            },
            "to_value": {
              "signature": "(self)",
              "called_by": [
                "get_action_button",
                "get_muted_list_section"
              ]
            }
          },
          "inherits": [
            "NamedTuple"
          ],
          "properties": [
            "id",
            "mute_type",
            "channel"
          ]
        }
      },
      "constants": {
        "INTERVAL": "number",
        "INTERVAL_UNIT": "value",
        "CHICAGO_TZ": "value",
        "HUMAN_DATETIME_FORMAT": "str",
        "MAX_BLOCKS_PER_MESSAGE": "number"
      },
      "call_graph": {},
      "enums": {
        "ActionId": {
          "values": [
            "MUTE_ENTITY",
            "UNMUTE_ENTITY",
            "MUTED_ENTITIES"
          ],
          "doc": ""
        }
      }
    },
    "app\\logic\\alerts\\__init__.py": {
      "language": "python",
      "parsed": false
    },
    "app\\logic\\auth\\security.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "datetime",
        "functools",
        "secrets",
        "jose",
        "sqlmodel",
        "fastapi.security",
        "fastapi",
        "config",
        "models.user",
        "logic.auth.service",
        "db.database",
        "uuid",
        "uuid",
        "logic.auth.service"
      ],
      "functions": {
        "create_access_token": "(data: dict, expires_delta: Optional[timedelta] = None, jwt_id: Optional[str] = None)",
        "create_refresh_token": "(data: dict, jwt_id: Optional[str] = None)",
        "verify_refresh_token": "(token: str) -> Optional[str]",
        "get_jwt_id_from_token": {
          "doc": "Extract JWT ID from token for session tracking",
          "signature": "(token: str) -> Optional[str]"
        },
        "get_current_user": "(token: str = Depends(oauth2_scheme))",
        "get_current_active_user": "(current_user: User = Depends(get_current_user))",
        "require_permission": {
          "doc": "Decorator to require specific permission",
          "calls": [
            "decorator",
            "wrapper"
          ],
          "signature": "(permission: str)"
        },
        "rate_limit": {
          "doc": "Rate limiting decorator",
          "calls": [
            "decorator",
            "wrapper"
          ],
          "signature": "(max_requests: int, window_minutes: int)"
        },
        "audit_log": {
          "doc": "Decorator to automatically log actions",
          "calls": [
            "decorator",
            "wrapper"
          ],
          "signature": "(action: str, resource: str)"
        },
        "generate_reset_token": {
          "doc": "Generate a secure password reset token",
          "signature": "() -> str"
        },
        "generate_verification_token": {
          "doc": "Generate a secure email verification token",
          "signature": "() -> str"
        },
        "verify_static_token": "(x_api_key: str = Header(..., description=\"Your secret API token.\"))",
        "verify_webhook_token": "(token: str = Query(..., description=\"Secret API token.\"))"
      },
      "classes": {
        "PermissionChecker": {
          "methods": {
            "__init__": {
              "signature": "(self, required_permission: str = None, required_resource: str = None, required_action: str = None)",
              "called_by": [
                "PermissionResponse.__init__",
                "RoleUpdate.__init__",
                "SessionResponse.__init__",
                "AuditLogResponse.__init__",
                "RoleCreate.__init__",
                "RoleResponse.__init__"
              ]
            },
            "__call__": "(self, current_user: User = Depends(get_current_active_user))"
          }
        }
      },
      "call_graph": {}
    },
    "app\\logic\\auth\\service.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "typing",
        "datetime",
        "sqlmodel",
        "passlib.context",
        "secrets",
        "uuid",
        "models.user",
        "db.database",
        "db.retry",
        "random",
        "services.email_service"
      ],
      "functions": {
        "utc_now": {
          "doc": "Get current UTC time as timezone-aware datetime",
          "signature": "()",
          "called_by": [
            "UserService.create_pending_verification",
            "UserService.verify_otp_and_create_user",
            "UserService.update_user",
            "UserService.update_last_login",
            "SessionService.create_session",
            "SessionService.cleanup_expired_sessions",
            "SessionService.get_active_sessions_count",
            "TokenStatusService.get_token_status",
            "TokenStatusService.cleanup_expired_sessions"
          ]
        },
        "make_timezone_aware": {
          "doc": "Convert naive datetime to timezone-aware UTC datetime",
          "signature": "(dt)",
          "called_by": [
            "TokenStatusService.get_token_status"
          ]
        },
        "create_user": {
          "calls": [
            "create_user"
          ],
          "signature": "(user_data)",
          "called_by": [
            "create_user",
            "create_user"
          ]
        },
        "authenticate_user": {
          "calls": [
            "authenticate_user"
          ],
          "signature": "(user_data)",
          "called_by": [
            "authenticate_user"
          ]
        }
      },
      "classes": {
        "UserService": {
          "methods": {
            "hash_password": {
              "decorators": [
                "staticmethod"
              ],
              "signature": "(password: str) -> str",
              "called_by": [
                "UserService.create_user",
                "UserService.create_pending_verification"
              ]
            },
            "verify_password": {
              "decorators": [
                "staticmethod"
              ],
              "signature": "(plain_password: str, hashed_password: str) -> bool",
              "called_by": [
                "UserService.authenticate_user"
              ]
            },
            "create_user": {
              "decorators": [
                "staticmethod"
              ],
              "calls": [
                "hash_password"
              ],
              "signature": "(user_data: UserCreate, created_by: Optional[int] = None, status: Optional[str] = None) -> User",
              "called_by": [
                "create_user"
              ]
            },
            "create_pending_verification": {
              "decorators": [
                "staticmethod"
              ],
              "doc": "Store user data temporarily until OTP is verified",
              "calls": [
                "hash_password",
                "utc_now"
              ],
              "signature": "(user_data: UserCreate) -> PendingEmailVerification"
            },
            "verify_otp_and_create_user": {
              "decorators": [
                "staticmethod"
              ],
              "doc": "Verify OTP code and create the actual user",
              "calls": [
                "utc_now"
              ],
              "signature": "(email: str, otp_code: str) -> Optional[User]"
            },
            "authenticate_user": {
              "decorators": [
                "staticmethod",
                "db_retry"
              ],
              "calls": [
                "verify_password"
              ],
              "signature": "(username: str, password: str) -> Optional[User]",
              "called_by": [
                "authenticate_user"
              ]
            },
            "get_user_by_id": {
              "decorators": [
                "staticmethod"
              ],
              "signature": "(user_id: int) -> Optional[User]"
            },
            "get_user_by_username": {
              "decorators": [
                "staticmethod",
                "db_retry"
              ],
              "signature": "(username: str) -> Optional[User]"
            },
            "get_user_by_email": {
              "decorators": [
                "staticmethod",
                "db_retry"
              ],
              "signature": "(email: str) -> Optional[User]"
            },
            "update_user": {
              "decorators": [
                "staticmethod"
              ],
              "calls": [
                "log_action",
                "utc_now"
              ],
              "signature": "(user_id: int, user_data: UserUpdate, updated_by: Optional[int] = None) -> Optional[User]"
            },
            "delete_user": {
              "decorators": [
                "staticmethod"
              ],
              "calls": [
                "log_action"
              ],
              "signature": "(user_id: int, deleted_by: Optional[int] = None) -> bool",
              "called_by": [
                "delete_user"
              ]
            },
            "get_user_permissions": {
              "decorators": [
                "staticmethod"
              ],
              "signature": "(user_id: int) -> List"
            },
            "get_user_roles": {
              "decorators": [
                "staticmethod"
              ],
              "signature": "(user_id: int) -> List"
            },
            "update_last_login": {
              "decorators": [
                "staticmethod"
              ],
              "calls": [
                "utc_now"
              ],
              "signature": "(user_id: int)"
            }
          }
        },
        "SessionService": {
          "methods": {
            "create_session": {
              "decorators": [
                "staticmethod"
              ],
              "calls": [
                "utc_now"
              ],
              "signature": "(user_id: int, ip_address: str, user_agent: str, expires_in_hours: int = 24) -> UserSession"
            },
            "get_session": {
              "decorators": [
                "staticmethod"
              ],
              "signature": "(session_id: str) -> Optional[UserSession]",
              "called_by": [
                "DriverReport.get_all",
                "TempSensorMapping.delete",
                "ActiveLoadTracking.create",
                "DispatchedTrip.delete_by_trip_key",
                "Driver.get_all",
                "TempSensorMapping.get_by_sensor_id",
                "ActiveLoadTracking.delete",
                "Driver.upsert",
                "ActiveLoadTracking.get_by_id",
                "ActiveLoadTracking.get_by_created_at",
                "DriverMorningReport.get_by_driver_id",
                "TrailerUnitMapping.update",
                "TrailerUnitMapping.get_by_trailer_unit",
                "DriverReport.get_by_trip_id",
                "TruckMapping.get_by_truck_id",
                "ActiveLoadTracking.update_mute_flag_by_trip_id",
                "DriverTripData.get_all",
                "ActiveLoadTracking.get_by_mute_flag",
                "ActiveLoadTracking.update",
                "Trip.upsert",
                "DriverTripData.get_by_driver",
                "TruckMapping.create",
                "TruckMapping.get_by_truck_unit",
                "ViolationAlertDriver.get_all",
                "Trip.create",
                "DispatchedTrip.update",
                "DriverTripData.get_latest_by_driver",
                "TrailerUnitMapping.delete",
                "TruckMapping.get_by_truck_key",
                "ViolationAlert.get_by_id",
                "Driver.get_by_id",
                "ViolationAlert.get_by_created_at",
                "DriverMapping.update",
                "Driver.get_by_telegram_id",
                "ViolationAlertDriver.get_by_trip_id",
                "TempSensorMapping.upsert",
                "DispatchedTrip.delete",
                "DriverMorningReport.get_all",
                "TempSensorMapping.get_by_sensor_name",
                "DriverMapping.get_with_filters",
                "ViolationAlert.upsert",
                "DriverMapping.get_by_driverkey",
                "TruckMapping.get_all",
                "ViolationAlert.get_all",
                "Driver.bulk_upsert",
                "ActiveLoadTracking.get_by_status",
                "DispatchedTrip.get_all",
                "DriverMapping.get_by_driverid",
                "ViolationAlert.create",
                "ViolationAlert.delete",
                "TrailerUnitMapping.upsert",
                "Trip.update",
                "TruckMapping.delete",
                "Driver.bulk_update_calling_info",
                "DriverTriggersData.get_trip_by_driver_id",
                "DriverTripData.get_by_trip",
                "DriverMapping.create",
                "ActiveLoadTracking.upsert",
                "ActiveLoadTracking.get_all",
                "Trip.truncate_table",
                "Trip.delete",
                "DispatchedTrip.upsert",
                "TruckMapping.upsert",
                "TrailerUnitMapping.get_all",
                "TruckMapping.update",
                "DriverMapping.delete",
                "Trip.get_by_driver_id",
                "ViolationAlert.update",
                "TempSensorMapping.create",
                "DispatchedTrip.get_by_id",
                "TrailerUnitMapping.get_by_trailer_id",
                "Driver.get_by_ids",
                "TempSensorMapping.get_all",
                "TempSensorMapping.update",
                "Trip.get_all",
                "DispatchedTrip.create",
                "ActiveLoadTracking.get_by_trip",
                "TrailerUnitMapping.create",
                "Trip.get_by_trip_id"
              ]
            },
            "invalidate_session": {
              "decorators": [
                "staticmethod"
              ],
              "signature": "(session_id: str) -> bool"
            },
            "cleanup_expired_sessions": {
              "decorators": [
                "staticmethod"
              ],
              "doc": "Mark expired sessions as inactive (soft delete approach)",
              "calls": [
                "utc_now"
              ],
              "signature": "()",
              "called_by": [
                "cleanup_expired_sessions"
              ]
            },
            "invalidate_user_sessions": {
              "decorators": [
                "staticmethod"
              ],
              "doc": "Invalidate all active sessions for a user",
              "signature": "(user_id: int) -> int"
            },
            "get_active_sessions_count": {
              "decorators": [
                "staticmethod"
              ],
              "doc": "Get count of currently active sessions",
              "calls": [
                "utc_now"
              ],
              "signature": "() -> int"
            }
          }
        },
        "TokenStatusService": {
          "methods": {
            "revoke_token": {
              "decorators": [
                "staticmethod"
              ],
              "doc": "Revoke a specific token by JWT ID",
              "signature": "(jti: str, reason: str = \"admin_revoked\")"
            },
            "get_token_status": {
              "decorators": [
                "staticmethod"
              ],
              "doc": "Get current token status ('active', 'revoked', 'expired', or 'not_found')",
              "calls": [
                "make_timezone_aware",
                "utc_now"
              ],
              "signature": "(jti: str) -> str"
            },
            "revoke_all_user_tokens": {
              "decorators": [
                "staticmethod"
              ],
              "doc": "Revoke all active tokens for a user (force logout)",
              "signature": "(user_id: int, reason: str = \"force_logout\")"
            },
            "cleanup_expired_sessions": {
              "decorators": [
                "staticmethod"
              ],
              "doc": "Mark expired sessions",
              "calls": [
                "utc_now"
              ],
              "signature": "()",
              "called_by": [
                "cleanup_expired_sessions"
              ]
            }
          }
        },
        "AuditService": {
          "methods": {
            "log_business_event": {
              "decorators": [
                "staticmethod"
              ],
              "doc": "Log meaningful business events, not API requests",
              "signature": "(user_id: Optional[int], action: str, resource: str, resource_id: Optional[str] = None, old_values: Optional[dict] = None, new_values: Optional[dict] = None, ip_address: Optional[str] = None, user_agent: Optional[str] = None, status: str = \"success\", error_message: Optional[str] = None)",
              "called_by": [
                "AuditService.log_action"
              ]
            },
            "log_action": {
              "decorators": [
                "staticmethod"
              ],
              "doc": "Legacy method for backward compatibility",
              "calls": [
                "log_business_event"
              ],
              "signature": "(user_id: Optional[int], action: str, resource: str, resource_id: Optional[str] = None, old_values: Optional[dict] = None, new_values: Optional[dict] = None, ip_address: Optional[str] = None, user_agent: Optional[str] = None, status: AuditStatus = AuditStatus.SUCCESS, error_message: Optional[str] = None)",
              "called_by": [
                "UserService.delete_user",
                "UserService.update_user"
              ]
            }
          }
        }
      },
      "call_graph": {}
    },
    "app\\logic\\auth\\__init__.py": {
      "language": "python",
      "parsed": false
    },
    "app\\logic\\ingest\\ditat.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "datetime",
        "pandas_gbq",
        "config",
        "helpers.utils",
        "providers.ditat"
      ],
      "functions": {
        "ingest_ditat_data": "()"
      },
      "classes": {},
      "call_graph": {}
    },
    "app\\logic\\ingest\\samsara.py": {
      "language": "python",
      "parsed": true,
      "imports": [
        "datetime",
        "numpy",
        "pandas",
        "pandas_gbq",
        "config",
        "helpers.utils",
        "providers.samsara",
        "helpers.pandas_utils"
      ],
      "functions": {
        "ingest_trailer_temp_data": "(ingested_at: datetime.datetime | None = None)",
        "ingest_trailer_stats_data": "(ingested_at: datetime.datetime | None = None)",
        "ingest_detailed_trailer_stats_data": "(ingested_at: datetime.datetime | None = None, start_time: datetime.datetime | None = None, end_time: datetime.datetime | None = None,)",
        "ingest_detailed_location_data": "(ingested_at: datetime.datetime | None = None)"
      },
      "classes": {},
      "constants": {
        "TAG_IDS": "collection"
      },
      "call_graph": {}
    },
    "app\\logic\\ingest\\__init__.py": {
      "language": "python",
      "parsed": false
    }
  },
  "dependency_graph": {
    "app\\config.py": [
      "pydantic_settings"
    ],
    "app\\ingest_app.py": [
      "fastapi",
      "fastapi.middleware.cors",
      "services",
      "db.database",
      "sqlmodel",
      "uvicorn"
    ],
    "app\\main.py": [
      "fastapi",
      "fastapi.middleware.cors",
      "fastapi.responses",
      "sentry_sdk",
      "sentry_sdk.integrations.fastapi",
      "sentry_sdk.integrations.starlette",
      "config",
      "services",
      "services.users",
      "services.vapi",
      "services.reports",
      "services.pcmiler",
      "services.slack",
      "services.weather",
      "services.truck_mapping",
      "services.temp_sensor_mapping",
      "services.trailer_unit_mapping",
      "services.active_load_tracking",
      "services.violation_alerts",
      "services.dispatched_trips",
      "services.driver_mapping",
      "services.driver_prompt_service",
      "services.admin_users",
      "services.admin_roles",
      "services.admin_permissions",
      "services.admin_sessions",
      "services.admin_audit",
      "services.admin_export",
      "services.test_service",
      "services.driver_data",
      "services.driver_triggers",
      "services.page_access_token_service",
      "db.database",
      "sqlmodel",
      "uvicorn"
    ],
    "cloud_functions\\get-trip-data\\main.py": [
      "re",
      "json",
      "pandas_gbq",
      "flask",
      "functions_framework"
    ],
    "app\\db\\database.py": [
      "sqlmodel",
      "sqlalchemy.engine.url",
      "sqlalchemy",
      "config"
    ],
    "app\\db\\retry.py": [
      "time",
      "functools",
      "typing",
      "sqlalchemy.exc",
      "logging"
    ],
    "app\\helpers\\agy_utils.py": [
      "re",
      "enum",
      "fastapi"
    ],
    "app\\helpers\\cloud_logger.py": [
      "json",
      "logging",
      "sys"
    ],
    "app\\helpers\\pandas_utils.py": [
      "json",
      "enum",
      "collections",
      "pandas",
      "helpers.utils"
    ],
    "app\\helpers\\time_utils.py": [
      "enum",
      "datetime"
    ],
    "app\\helpers\\utils.py": [
      "json",
      "logging",
      "traceback",
      "concurrent.futures",
      "typing"
    ],
    "app\\logic\\trips.py": [
      "json",
      "typing",
      "datetime",
      "pandas",
      "pandas_gbq",
      "fastapi",
      "helpers.time_utils",
      "helpers.agy_utils",
      "utils.weather_api"
    ],
    "app\\logic\\weather.py": [
      "httpx",
      "typing",
      "config"
    ],
    "app\\models\\alert_filter.py": [
      "datetime",
      "enum",
      "typing",
      "sqlmodel",
      "pydantic",
      "helpers.agy_utils"
    ],
    "app\\models\\drivers.py": [
      "typing",
      "sqlmodel",
      "pydantic",
      "db",
      "helpers"
    ],
    "app\\models\\driver_data.py": [
      "typing",
      "sqlmodel",
      "db",
      "logging",
      "utils.vapi_client",
      "models.vapi",
      "config",
      "httpx",
      "fastapi",
      "models.driver_model_prompt",
      "traceback",
      "models.trips",
      "random",
      "models.vapi",
      "models.vapi",
      "traceback",
      "json",
      "traceback"
    ],
    "app\\models\\driver_mapping.py": [
      "typing",
      "sqlmodel",
      "db",
      "helpers"
    ],
    "app\\models\\driver_model_prompt.py": [
      "typing",
      "datetime",
      "sqlmodel",
      "uuid"
    ],
    "app\\models\\driver_reports.py": [
      "typing",
      "datetime",
      "sqlmodel",
      "db",
      "helpers"
    ],
    "app\\models\\driver_triggers.py": [
      "typing",
      "sqlmodel",
      "db",
      "logging",
      "fastapi",
      "httpx",
      "config"
    ],
    "app\\models\\load_tracking.py": [
      "typing",
      "datetime",
      "decimal",
      "sqlmodel",
      "pydantic",
      "db",
      "helpers"
    ],
    "app\\models\\page_access_token_model.py": [
      "typing",
      "datetime",
      "sqlmodel",
      "uuid"
    ],
    "app\\models\\pcmiler.py": [
      "typing",
      "pydantic"
    ],
    "app\\models\\slack.py": [
      "enum",
      "pydantic",
      "requests",
      "config"
    ],
    "app\\models\\temp_sensor_mapping.py": [
      "typing",
      "sqlmodel",
      "db",
      "helpers",
      "sqlalchemy",
      "sqlalchemy",
      "sqlalchemy"
    ],
    "app\\models\\test_modal.py": [
      "pydantic",
      "typing",
      "logging"
    ],
    "app\\models\\trailer_unit_mapping.py": [
      "typing",
      "sqlmodel",
      "db",
      "helpers"
    ],
    "app\\models\\trips.py": [
      "typing",
      "datetime",
      "decimal",
      "sqlmodel",
      "db",
      "helpers"
    ],
    "app\\models\\truck_mapping.py": [
      "typing",
      "sqlmodel",
      "db",
      "helpers"
    ],
    "app\\models\\user.py": [
      "typing",
      "datetime",
      "sqlmodel",
      "sqlalchemy",
      "enum"
    ],
    "app\\models\\vapi.py": [
      "typing",
      "pydantic"
    ],
    "app\\providers\\ditat.py": [
      "typing",
      "logging",
      "requests",
      "pandas"
    ],
    "app\\providers\\samsara.py": [
      "logging",
      "uuid",
      "datetime",
      "typing",
      "requests",
      "pandas",
      "helpers.utils"
    ],
    "app\\services\\active_load_tracking.py": [
      "typing",
      "fastapi",
      "fastapi.responses",
      "helpers",
      "logic.auth.security",
      "models.load_tracking",
      "datetime"
    ],
    "app\\services\\admin_audit.py": [
      "typing",
      "datetime",
      "math",
      "fastapi",
      "sqlmodel",
      "models.user",
      "logic.auth.security",
      "db.database"
    ],
    "app\\services\\admin_export.py": [
      "csv",
      "io",
      "typing",
      "fastapi",
      "fastapi.responses",
      "sqlmodel",
      "models.user",
      "logic.auth.service",
      "logic.auth.security",
      "db.database",
      "models.user"
    ],
    "app\\services\\admin_permissions.py": [
      "typing",
      "fastapi",
      "sqlmodel",
      "models.user",
      "logic.auth.security",
      "db.database"
    ],
    "app\\services\\admin_roles.py": [
      "typing",
      "fastapi",
      "sqlmodel",
      "models.user",
      "logic.auth.service",
      "logic.auth.security",
      "db.database"
    ],
    "app\\services\\admin_sessions.py": [
      "typing",
      "math",
      "fastapi",
      "sqlmodel",
      "models.user",
      "logic.auth.service",
      "logic.auth.security",
      "db.database"
    ],
    "app\\services\\admin_users.py": [
      "typing",
      "datetime",
      "math",
      "fastapi",
      "sqlmodel",
      "config",
      "models.user",
      "logic.auth.service",
      "logic.auth.security",
      "db.database",
      "models.user",
      "logic.auth.service",
      "logic.auth.service",
      "logic.auth.service",
      "logic.auth.service",
      "logic.auth.service",
      "logic.auth.service",
      "secrets",
      "string",
      "logic.auth.service",
      "logic.auth.service",
      "models.user",
      "models.user",
      "models.user",
      "logic.auth.service",
      "models.user",
      "logic.auth.service",
      "logic.auth.security",
      "logic.auth.service",
      "logic.auth.service",
      "logic.auth.service",
      "logic.auth.service"
    ],
    "app\\services\\auth.py": [
      "datetime",
      "typing",
      "fastapi.security",
      "fastapi",
      "config",
      "models.user",
      "logic.auth.service",
      "logic.auth.security",
      "models.user",
      "sqlmodel",
      "db.database",
      "uuid",
      "models.user",
      "sqlmodel",
      "db.database",
      "models.user",
      "sqlmodel",
      "db.database",
      "logic.auth.security",
      "logic.auth.service"
    ],
    "app\\services\\dispatched_trips.py": [
      "typing",
      "fastapi",
      "fastapi.responses",
      "helpers",
      "logic.auth.security",
      "models.load_tracking"
    ],
    "app\\services\\drivers.py": [
      "typing",
      "fastapi",
      "fastapi.responses",
      "helpers",
      "logic.auth.security",
      "models.drivers"
    ],
    "app\\services\\driver_data.py": [
      "fastapi",
      "models.driver_data",
      "models.vapi"
    ],
    "app\\services\\driver_mapping.py": [
      "typing",
      "fastapi",
      "fastapi.responses",
      "helpers",
      "logic.auth.security",
      "models.driver_mapping"
    ],
    "app\\services\\driver_prompt_service.py": [
      "fastapi",
      "sqlmodel",
      "datetime",
      "db",
      "models.driver_model_prompt",
      "typing",
      "pydantic",
      "uuid"
    ],
    "app\\services\\driver_triggers.py": [
      "fastapi",
      "models.driver_triggers",
      "pydantic",
      "typing"
    ],
    "app\\services\\email_service.py": [
      "smtplib",
      "email.mime.text",
      "email.mime.multipart",
      "typing",
      "config"
    ],
    "app\\services\\ingest.py": [
      "datetime",
      "fastapi",
      "fastapi.responses",
      "helpers",
      "logic.auth.security",
      "helpers.time_utils",
      "helpers.utils",
      "logic.ingest"
    ],
    "app\\services\\page_access_token_service.py": [
      "fastapi",
      "sqlmodel",
      "typing",
      "uuid",
      "logic.auth.security",
      "models.page_access_token_model",
      "db.database",
      "pydantic"
    ],
    "app\\services\\pcmiler.py": [
      "datetime",
      "typing",
      "fastapi",
      "httpx",
      "helpers",
      "logic.auth.security",
      "models.pcmiler",
      "config"
    ],
    "app\\services\\reports.py": [
      "typing",
      "fastapi",
      "helpers",
      "logic.auth.security",
      "models.driver_reports",
      "models.drivers"
    ],
    "app\\services\\slack.py": [
      "json",
      "time",
      "hmac",
      "hashlib",
      "fastapi",
      "helpers",
      "config",
      "logic.alerts"
    ],
    "app\\services\\temp_sensor_mapping.py": [
      "typing",
      "fastapi",
      "fastapi.responses",
      "helpers",
      "logic.auth.security",
      "models.temp_sensor_mapping"
    ],
    "app\\services\\test_service.py": [
      "fastapi",
      "models",
      "fastapi"
    ],
    "app\\services\\trailer_unit_mapping.py": [
      "typing",
      "fastapi",
      "fastapi.responses",
      "helpers",
      "logic.auth.security",
      "models.trailer_unit_mapping"
    ],
    "app\\services\\trips.py": [
      "typing",
      "fastapi",
      "fastapi.responses",
      "pydantic",
      "helpers.time_utils",
      "logic.trips",
      "logic.auth.security",
      "logic.trips",
      "models.trips",
      "helpers",
      "datetime"
    ],
    "app\\services\\truck_mapping.py": [
      "typing",
      "fastapi",
      "fastapi.responses",
      "helpers",
      "logic.auth.security",
      "models.truck_mapping"
    ],
    "app\\services\\users.py": [
      "typing",
      "datetime",
      "fastapi",
      "sqlmodel",
      "models.user",
      "logic.auth.security",
      "logic.auth.service",
      "db.database"
    ],
    "app\\services\\vapi.py": [
      "typing",
      "fastapi",
      "fastapi.responses",
      "helpers",
      "logic.auth.security",
      "models.drivers",
      "models.driver_reports",
      "models.vapi",
      "utils.vapi_client",
      "sqlmodel",
      "sqlmodel"
    ],
    "app\\services\\violation_alerts.py": [
      "typing",
      "fastapi",
      "fastapi.responses",
      "helpers",
      "logic.auth.security",
      "models.load_tracking"
    ],
    "app\\services\\weather.py": [
      "fastapi",
      "typing",
      "pydantic",
      "logic.weather",
      "logic.auth.security",
      "models.user"
    ],
    "app\\services\\webhook.py": [
      "fastapi",
      "fastapi.responses",
      "models.alert_filter",
      "logic.auth.security",
      "helpers.agy_utils",
      "logic.alerts"
    ],
    "app\\utils\\call_insights.py": [
      "re",
      "typing"
    ],
    "app\\utils\\vapi_client.py": [
      "httpx",
      "typing",
      "config",
      "helpers"
    ],
    "app\\utils\\weather_api.py": [
      "json",
      "dataclasses",
      "datetime",
      "pytz",
      "requests",
      "pandas",
      "pandas_gbq",
      "fastapi",
      "config",
      "helpers.utils"
    ],
    "app\\services\\alerts\\filters.py": [
      "fastapi",
      "logic.alerts",
      "logic.auth.security",
      "helpers.agy_utils",
      "models.alert_filter"
    ],
    "app\\services\\alerts\\slack.py": [
      "fastapi",
      "fastapi.responses",
      "logic.alerts",
      "logic.auth.security"
    ],
    "app\\logic\\alerts\\filters.py": [
      "collections",
      "datetime",
      "pandas",
      "sqlmodel",
      "helpers",
      "db.database",
      "helpers.agy_utils",
      "models.alert_filter"
    ],
    "app\\logic\\alerts\\slack.py": [
      "enum",
      "datetime",
      "typing",
      "collections",
      "cachetools",
      "fastapi",
      "pytz",
      "pandas",
      "pandas_gbq",
      "config",
      "models.slack",
      "models.alert_filter",
      "helpers.agy_utils",
      "helpers.time_utils",
      "logic.alerts.filters",
      "utils.weather_api"
    ],
    "app\\logic\\auth\\security.py": [
      "typing",
      "datetime",
      "functools",
      "secrets",
      "jose",
      "sqlmodel",
      "fastapi.security",
      "fastapi",
      "config",
      "models.user",
      "logic.auth.service",
      "db.database",
      "uuid",
      "uuid",
      "logic.auth.service"
    ],
    "app\\logic\\auth\\service.py": [
      "typing",
      "datetime",
      "sqlmodel",
      "passlib.context",
      "secrets",
      "uuid",
      "models.user",
      "db.database",
      "db.retry",
      "random",
      "services.email_service"
    ],
    "app\\logic\\ingest\\ditat.py": [
      "datetime",
      "pandas_gbq",
      "config",
      "helpers.utils",
      "providers.ditat"
    ],
    "app\\logic\\ingest\\samsara.py": [
      "datetime",
      "numpy",
      "pandas",
      "pandas_gbq",
      "config",
      "helpers.utils",
      "providers.samsara",
      "helpers.pandas_utils"
    ]
  },
  "staleness_check": 1762996421.702506
}